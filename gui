#!/bin/bash

AUTOMATON_DIR="$(readlink -f "$(dirname "$0")")"

source "$AUTOMATON_DIR/api" || exit 1

#functions defined below are not available to userscripts.
gui_pick_region() { #use region-picker.py to pick a rectangular region of the $1 image, outputs rectangle coordinates (X,Y +W+H)
  if [ ! -f "$1" ];then
    error "gui_pick_region(): provided image '$1' does not exist!"
  fi
  "${AUTOMATON_DIR}/region-picker.py" "$1" rectangle
}

gui_pick_pixel() { #use region-picker.py to pick a pixel of the $1 image, outputs coordinates (X,Y)
  if [ ! -f "$1" ];then
    error "gui_pick_pixel(): provided image '$1' does not exist!"
  fi
  "${AUTOMATON_DIR}/region-picker.py" "$1" pixel
}

gui_pick_pixel_on_screen() { #uses a temporary screenshot, outputs coordinates (X,Y)
  local screenshot="$RAM_LOCATION/automaton-gui_pick_pixel_on_screen.png"
  
  screenshot_fullscreen "$screenshot" || return 1
  gui_pick_pixel "$screenshot" || return 1
  rm -f "$screenshot"
}

generate_thumbnail() { #convert full size screenshot filename (already in cache) and shrink it for thumbnail folder
  local filename="$1"
  if [ ! -f "$SCREENSHOTS_CACHE/$filename" ];then
    error "generate_thumbnail(): file '$SCREENSHOTS_CACHE/$filename' does not exist!"
  elif [ -f "$THUMBNAILS_CACHE/$filename" ];then
    #if thumbnail already exists, remove it first
    rm "$THUMBNAILS_CACHE/$filename"
  fi
  convert "$SCREENSHOTS_CACHE/$filename" -resize 25% "$THUMBNAILS_CACHE/$filename"
}

rename_screenshot() { #rename $1 filename to $2
  local filename="$1"
  local destination="$2"
  if [ ! -f "$SCREENSHOTS_CACHE/$filename" ];then
    error "rename_screenshot(): file '$SCREENSHOTS_CACHE/$filename' does not exist!"
  elif [ -z "$destination" ];then
    error "rename_screenshot(): destination filename not specified!"
  elif [ -f "$SCREENSHOTS_CACHE/$destination" ];then
    error "rename_screenshot(): refusing to overwrite '$SCREENSHOTS_CACHE/$destination'"
  fi
  
  mv -f "$SCREENSHOTS_CACHE/$filename" "$SCREENSHOTS_CACHE/$destination"
  mv -f "$THUMBNAILS_CACHE/$filename" "$THUMBNAILS_CACHE/$destination"
}

remove_screenshot() { #delete the $1 screenshot
  rm -f "$SCREENSHOTS_CACHE/$1" "$THUMBNAILS_CACHE/$1"
}

gui_capture_screenshot() { #take a fullscreen screenshot, name it, save to cache, save thumbnail, echo filename
  local date="$(date +"%Y-%m-%d %X")"
  screenshot_fullscreen "$SCREENSHOTS_CACHE/$date.png"
  generate_thumbnail "$date.png"
  
  #now ask the user what to name the screenshot
  local final_filename button
  local text="Screenshot captured. Choose a unique name:"
  while true;do
    final_filename="$(yad "${yadflags[@]}" --image="$THUMBNAILS_CACHE/$date.png" --image-on-top \
      --form --field="$text:LBL" "" \
      --field='' "$date" --button=Cancel:1 --button=OK:0)"
    button=$?
    final_filename="$(echo "$final_filename" | tail -n +2).png"
    if [ $button != 0 ];then
      remove_screenshot "$date.png"
      error "User exited screenshot naming dialog" #user cancelled the dialog
    elif [ "$final_filename" == "$date.png" ];then
      #user did not rename the file, so leave it as-is
      break
    elif [ -f "$THUMBNAILS_CACHE/$final_filename" ];then
      text="That name is already taken."$'\n'"$text"
    elif [ "$final_filename" == '.png' ];then
      text="Name cannot be left blank."$'\n'"$text"
    else
      #user chose a valid unique filename
      rename_screenshot "$date.png" "$final_filename"
      break
    fi
  done
  
  echo "$final_filename"
}

gui_screenshot_picker() { #pick a screenshot from the automaton cache. outputs a filename.
  local IFS=$'\n'
  local button
  local first_loop=1
  
  #add a new screenshot buttons before looping through existing screenshots
  (echo "New screenshot
Capture a new screenshot when clicked
${AUTOMATON_DIR}/icons/new-screenshot.png
bash -c "\""kill "\$"YAD_PID; yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n'); sleep 1; gui_capture_screenshot"\""
FALSE
New screenshot (5s delay)
Capture a new screenshot 5 seconds after clicking this
${AUTOMATON_DIR}/icons/new-screenshot.png
bash -c "\""kill "\$"YAD_PID; yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n'); sleep 5; gui_capture_screenshot"\""
FALSE"
  find "$SCREENSHOTS_CACHE" -name '*.png' | sort | sed 's+.*/++g' | while read filename ;do
    
    #generate thumbnail for this screenshot if it somehow went missing
    if [ ! -f "$THUMBNAILS_CACHE/$filename" ];then
      generate_thumbnail "$filename" >/dev/null
    fi
    echo "$filename
$(identify -ping -format '%wx%h PNG image' "$SCREENSHOTS_CACHE/$filename")
$THUMBNAILS_CACHE/$filename
bash -c "\""echo $filename; kill "\$"YAD_PID"\""
FALSE"
  done) | yad "${yadflags[@]}" --maximized --icons --listen --item-width 100 --single-click --no-buttons --text="Choose a screenshot:"
  button=$?
  if [ $button != 0 ] && [ $button != 143 ];then
    error "User exited gui_screenshot_picker"
  fi
}

gui_pattern_picker() { #pick a pattern from this project's PATTERNS_DIR. outputs a filename.
  local IFS=$'\n'
  local button
  local first_loop=1
  
  #add a new pattern button before looping through existing patterns
  (echo "New pattern from screenshot
Crop a region from a screenshot to make a new pattern
${AUTOMATON_DIR}/icons/new-pattern.png
bash -c 'kill "\$"YAD_PID; yadflags=(--center --separator="\""\n"\""); gui_make_pattern "\"\$"(gui_screenshot_picker)"\""'
FALSE"
  find "$PATTERNS_DIR" -name '*.png' | sort | sed 's+.*/++g' | while read filename ;do
    #if first loop iteration, add a new pattern button
    
    echo "$filename
$(identify -ping -format '%wx%h PNG image' "$PATTERNS_DIR/$filename")
$PATTERNS_DIR/$filename
bash -c "\""echo $filename; kill "\$"YAD_PID"\""
FALSE"
  done) | yad "${yadflags[@]}" --maximized --icons --listen --item-width 100 --single-click --no-buttons --text="Choose a pattern:"
  button=$?
  if [ $button != 0 ] && [ $button != 143 ];then
    error "User exited gui_pattern_picker"
  fi
  error 'got here'
}

gui_make_pattern() { #from the $1 screenshot filename, prompt user to crop it, name it if $2 is blank, and output that filename
  local filename="$1"
  local screenshot="$SCREENSHOTS_CACHE/$filename"
  if [ -z "$filename" ];then
    error "gui_make_pattern(): needs a screenshot filename to do anything"
  elif [ ! -f "$screenshot" ];then
    error "gui_make_pattern(): file '$screenshot' does not exist!"
  fi
  local final_filename="$2" #optional argument to skip the naming dialog (overwriting allowed)
  
  local region
  region="$(gui_pick_region "$screenshot")" || return 1
  crop_image "$screenshot" "$region" "$RAM_LOCATION/automaton-new-pattern.png" || return 1
  
  #now ask the user what to name the pattern
  local button
  local text="Choose a unique name for this pattern:"
  while [ -z "$final_filename" ];do
    final_filename="$(yad "${yadflags[@]}" --image="$RAM_LOCATION/automaton-new-pattern.png" --image-on-top \
      --form --field="$text:LBL" "" \
      --field='' "$(echo "$filename" | sed 's/\.png$//g')" --button=OK:0 | tail -n +2 ; exit ${PIPESTATUS[0]}).png"
    button=$?
    if [ $button != 0 ];then
      error "User exited pattern naming dialog" #user cancelled the dialog
    elif [ -f "$PATTERNS_DIR/$final_filename" ];then
      text="That name is already taken."$'\n'"$text"
      final_filename=''
    elif [ "$final_filename" == '.png' ];then
      text="Name cannot be left blank."$'\n'"$text"
      final_filename=''
    else
      #user chose a valid unique filename
      break
    fi
  done
  
  mv -f "$RAM_LOCATION/automaton-new-pattern.png" "$PATTERNS_DIR/$final_filename" || error "Failed to move pattern to $PATTERNS_DIR/$final_filename"
  echo "$final_filename"
}

gui_test_pattern_live() { #indicate in real-time if pattern $1 is seen on screen or not.
  #pattern="$(gui_pattern_picker)" || exit 1
  local pattern="$1"
  local offset="$2"
  [ -z "$offset" ] && offset='+0+0'
  
  locator_start
  
  local IFS=' '
  local history=''
  while true;do
    if output="$(locate_pattern "$pattern" "$offset")" ;then
      read coordinates similarity <<<"$output"
      similarity="$(echo "$similarity" | tr -cd '0123456789')"
      found='✅ Yes'
      history="▰$history"
    else
      found='❌ No'
      coordinates=' '
      similarity='0'
      history="▱$history"
    fi
    
    #truncate length of history
    history="${history:0:40}"
    
    echo "coordinates: $coordinates similarity $similarity" 1>&2
    #refresh the yad window with these new values
    echo "$history
$found
$coordinates
$similarity
bash -c 'mouse_move $coordinates'"
    
  done | yad "${yadflags[@]}" --width=400 --text="Watching screen for pattern: <u><b>$pattern</b></u>" \
    --form --focus-field=3 --cycle-read --button=Close:0 \
    --field='Past results::RO' --field='Pattern found?:RO' --field=Coordinates: \
    --field='Similarity::SCL' --field='Move mouse to pattern':FBTN
}

text_editor() { #Open user-preferred text editor. $1 is file to open (function adapted from Pi-Apps)
  [ -z "$1" ] && error "text_editor(): no file specified"
  
  #find the best text editor
  local preferrededitor="$(cat "$AUTOMATON_CONFIG/text-editor" 2>/dev/null || echo geany)"
  # map friendly name of editors to binary name
  if [ "$preferrededitor" == "Visual Studio Code" ];then
    preferrededitor="code"
  elif [ "$preferrededitor" == "VSCodium" ];then
    preferrededitor="codium"
  fi
  
  #change preferred editor if user-default doesn't exist
  if ! command -v "$preferrededitor" >/dev/null;then
    preferrededitor=geany
  fi
  if ! command -v "$preferrededitor" >/dev/null;then
    preferrededitor=mousepad
  fi
  if ! command -v "$preferrededitor" >/dev/null;then
    preferrededitor=leafpad
  fi
  if ! command -v "$preferrededitor" >/dev/null;then
    local errormessage="text_editor(): could not detect any installed text editing programs on your system! Please install something like leafpad, mousepad, or geany. If you have a favorite text editor that is not detected, open an issue and it can be added to the list."
    yad --text="$errormessage" --button=OK:0
    error "$errormessage"
  fi
  
  #non-terminal text editor
  "$preferrededitor" "$1" &
}

#botspot: user needs to choose these
USERSCRIPT=~/Desktop/project1/project1.sh
PATTERNS_DIR=~/Desktop/project1/patterns
mkdir -p "$PATTERNS_DIR"

AUTOMATON_CONFIG=~/.config/automaton
SCREENSHOTS_CACHE="${AUTOMATON_CONFIG}/screenshots"
THUMBNAILS_CACHE="${AUTOMATON_CONFIG}/thumbnails"
mkdir -p "$SCREENSHOTS_CACHE" "$THUMBNAILS_CACHE" || error "Making cache folder failed, please review errors above"

#this needs to be set because api is sourced before PATTERNS_DIR is set, making the previous value /locator_pipe
locator_pipe="$AUTOMATON_CONFIG/locator_pipe"

yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n')

mode="$1"
mode=choose-project
mode=userscript-editor
while true;do
case "$mode" in
  choose-project) #project creation, selection, and onboarding
    
    #recall previous choices using a 2-line config file
    current_project_config_file="$AUTOMATON_CONFIG/current-project"
    if [ -f "$current_project_config_file" ];then
      USERSCRIPT="$(sed -n 1p "$current_project_config_file")"
      PATTERNS_DIR="$(sed -n 2p "$current_project_config_file")"
      if [ ! -f "$USERSCRIPT" ];then
        USERSCRIPT=''
      fi
      if [ ! -d "$PATTERNS_DIR" ];then
        PATTERNS_DIR=''
      fi
    fi
    
    interpret_patterns_dir_from_script() { #read the specified automaton script and try to find the path to the PATTERNS_DIR it is using. Output: folder path, and exit code 1 if it does not exist
      [ ! -f "$1" ] && error "interpret_patterns_dir_from_script(): script '$1' not found"
      local PATTERNS_DIR="$(grep -m1 -o 'PATTERNS_DIR=.*' "$1" | sed 's/#.*//g ; s+~/+'$HOME/'+g ; s+$HOME+'$HOME'+g ; s/^PATTERNS_DIR=//g ; s/^"//g ; s/"$//g')"
      echo "$PATTERNS_DIR" #send the interpreted PATTERNS_DIR to stdout
      [ -d "$PATTERNS_DIR" ] #return code 0 if found, otherwise return 1
    }
    
    yad_new_project_wizard() { #just for choose-project mode, this returns paths to script and patterns folders
      yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n')
      text="This <b>script</b> will perform automated tasks of your choosing. Choose a good place to save it."
      while true;do
        USERSCRIPT="$(cd $HOME/Documents; yad "${yadflags[@]}" --maximized --text="$text" --file --save \
          --filename=project1.sh --file-filter="Bash script | *.sh" \
          --confirm-overwrite="If you proceed with this file, its contents will be replaced with a few lines of template code. Are you sure?")"
        button=$?
        if [ "$button" != 0 ];then
          error "user exited project script naming dialog"
        elif [[ "$USERSCRIPT" != *'.sh' ]];then
          text+=$'\n'"Project script must end in .sh"
        else
          break
        fi
      done
      text="<b>Patterns</b> are small pictures that tell the script what to find on the screen. Choose a folder to store them."
      while true;do
        PATTERNS_DIR="$(cd "$(dirname "$USERSCRIPT")"; yad "${yadflags[@]}" --maximized --text="$text" --filename="$(basename "$USERSCRIPT" | sed 's/\.sh$/-patterns/g')" --file --directory --save)"
        button=$?
        if [ "$button" != 0 ];then
          error "user exited project folder naming dialog"
        else
          break
        fi
      done
      #send these values to yad's form fields
      echo "3:$USERSCRIPT" | sed "s+$HOME+~+g"
      echo "4:$PATTERNS_DIR" | sed "s+$HOME+~+g"
    }
    yad_existing_project_wizard() { #just for choose-project mode, this returns paths to script and patterns folders
      yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n')
      text="Choose a previously created Automaton script."
      while true;do
        USERSCRIPT="$(cd $HOME/Documents; yad "${yadflags[@]}" --maximized --text="$text" --file \
          --filename=project1.sh --file-filter="Bash scripts | *.sh")"
        button=$?
        if [ "$button" != 0 ];then
          error "user exited project script choosing dialog"
        elif ! grep -q 'PATTERNS_DIR=' "$USERSCRIPT" ;then
          yad "${yadflags[@]}" --text="<u>$USERSCRIPT</u>"$'\n'"That file does not mention 'PATTERNS_DIR=' anywhere. All Automaton projects must clearly reference the folder for storing patterns."$'\n'"Please fix the file or choose a different one." --button=OK
          error "That file does not mention 'PATTERNS_DIR=' anywhere."
        else
          
          if PATTERNS_DIR="$(interpret_patterns_dir_from_script "$USERSCRIPT")" ;then
            #script interpreted successfully, choose this PATTERNS_DIR
            break
          else
            yad "${yadflags[@]}" --text="Failed to interpret the the PATTERNS_DIR= line in the script. This folder does not exist: <u>${PATTERNS_DIR}</u>"$'\n'"Please fix the file or choose a different one."
            error "Failed to interpret the the PATTERNS_DIR= line in the script. This folder does not exist: '${PATTERNS_DIR}'"
          fi
          
        fi
      done
      #send these values to yad's form fields
      echo "3:$USERSCRIPT" | sed "s+$HOME+~+g"
      echo "4:$PATTERNS_DIR" | sed "s+$HOME+~+g"
    }
    
    output="$(yad "${yadflags[@]}" --width=400 --form \
      --field='New Automaton project':FBTN "@bash -c 'yad_new_project_wizard'" \
      --field='Open existing project':FBTN "@bash -c 'yad_existing_project_wizard'" \
      --field='Script::RO' "$(echo "$USERSCRIPT" | sed "s+$HOME+~+g")" \
      --field='Patterns Folder::RO' "$(echo "$PATTERNS_DIR" | sed "s+$HOME+~+g")" \
      --button=Next:0)"
    USERSCRIPT="$(echo "$output" | sed -n 3p | sed "s+~+$HOME+g")"
    PATTERNS_DIR="$(echo "$output" | sed -n 4p | sed "s+~+$HOME+g")"
    
    #save new values to config file for next time
    echo "$USERSCRIPT"$'\n'"$PATTERNS_DIR" > "$current_project_config_file"
    
    #initialize script if necessary
    if [ ! -f "$USERSCRIPT" ] || ! interpret_patterns_dir_from_script "$USERSCRIPT" >/dev/null ;then
      #script invalid or does not exist, so make it
      if [ -f "$USERSCRIPT" ] && [ ! -f "$USERSCRIPT.bak" ];then
        #if it exists already, then move to backup location
        status "Saving a backup of pre-existing script '$USERSCRIPT' to '$USERSCRIPT.bak'..."
        mv -f "$USERSCRIPT" "$USERSCRIPT.bak"
      fi
      rm -f "$USERSCRIPT" || error "Failed to first remove '$USERSCRIPT'"
      echo "#!/bin/bash

#exit this script on any errors
set -e

#folder that contains the patterns to be used by this script
PATTERNS_DIR=$(echo '"'"$PATTERNS_DIR"'"' | sed "s+"\""$HOME+"\"\$"HOME+g")

#get access to automaton's bash functions, including locate_pattern and mouse_move
AUTOMATON_DIR=$(echo '"'"$AUTOMATON_DIR"'"' | sed "s+"\""$HOME+"\"\$"HOME+g")
source "\"\$"AUTOMATON_DIR/api"\""

#this starts the pattern locator service. Comment this out if you don't use locate_pattern.
locator_start

#Your code begins below this line. Happy automating! -Botspot" > "$USERSCRIPT"
      #make the script executable
      chmod +x "$USERSCRIPT"
      #make the patterns directory
      mkdir -p "$PATTERNS_DIR"
    fi
    #set the next mode to use after this
    mode=userscript-editor
    ;;
  userscript-editor) #main gui where the user sets up their script
    if [ ! -f "$USERSCRIPT" ] || [ ! -d "$PATTERNS_DIR" ];then
      error "userscript-editor mode requires valid values for USERSCRIPT and PATTERNS_DIR."
    fi
    export USERSCRIPT
    #functions to be used by yad in userscript-editor mode:
    ask_ai() { #opens a browser to duck.ai, and provides a premade prompt
      yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n')
      
      ai_text_payload="I need help bash scripting on a $(cat /etc/os-release | grep PRETTY_NAME | tr -d '"' | awk -F= '{print $2}') Linux distro.
Please assume I have little scripting experience, so make explanations beginner-friendly. Use code tags. Do not write lengthy summaries at the end of your answers.
The script in question is named \`${USERSCRIPT}\` and is intended to automate graphical tasks in the $XDG_SESSION_TYPE desktop environment, using shell functions provided by the Automaton project on github.
Below is some documentation for Automaton.
\`\`\`
#botspot make a documentation file
$(cat "$AUTOMATON_DIR/documentation")
\`\`\`
Below is the current contents of \`${USERSCRIPT}\`:
\`\`\`bash
$(cat "${USERSCRIPT}")
\`\`\`"
      ai_text_payload="$(echo "$ai_text_payload" | yad "${yadflags[@]}" --text-info --tail --editable --wrap --back=black --fore='#00AAFF' \
        --text="<big>To get the best AI assistance, this text should be pasted into the beginning of your chat. Add your question to the end, then proceed.</big>" \
        --button="<big>Copy text and launch AI chat window</big>":0)"
      button=$?
      status "ai_text_payload=$ai_text_payload"
      if [ "$button" == 0 ] && [ ! -z "$ai_text_payload" ];then
        clipboard_set "$ai_text_payload"
        
        #opens a browser to duck.ai
        x-www-browser "https://duckduckgo.com/?q=DuckDuckGo+AI+Chat&ia=chat&duckai=1" &
      fi
    }
    
    test_userscript() { #run $USERSCRIPT in a visible terminal, add $1=debug for debug mode
      if [ "$1" == debug ];then
        "$AUTOMATON_DIR/terminal-run" "bash -x ${USERSCRIPT};echo 'Press Enter to exit.';read enter" "Running Automaton project in debug mode: $(basename ${USERSCRIPT})"
      else
        "$AUTOMATON_DIR/terminal-run" "${USERSCRIPT};echo 'Press Enter to exit.';read enter" "Running Automaton project: $(basename ${USERSCRIPT})"
      fi
    }
    
    draft_snippet() { #handles all GUI code snippet generators
      default_text="Customize the behavior of this code snippet, then paste it into your script."
      yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n')
      yad_common=("${yadflags[@]}" --form --text="$default_text" \
        --button="Copy code!!Then paste it into $(basename "${USERSCRIPT}")":0)
      
      mode="$1"
      case "$mode" in
        click|right-click|middle-click) #user wants a click function added to their script
          output="$(yad "${yad_common[@]}" \
            --field='Click type:CB' "$mode!$(echo -en 'click\nright-click\nmiddle-click' | grep -vx "$mode" | tr '\n' '!' | sed 's/!$//g')" \
            --field='Repetition:CB' "single click!double-click")"
          [ $? != 0 ] && return
          function_name="mouse_$(echo "$output" | sed -n 1p | tr '-' '_')"
          repetition="$(echo "$output" | sed -n 2p)"
          if [ "$repetition" == 'single click' ];then
            clipboard_set "$function_name"
          elif [ "$repetition" == 'double-click' ];then
            clipboard_set "$function_name"$'\n'"sleep 0.2"$'\n'"$function_name"
          fi
          ;;
        scroll)
          output="$(yad "${yad_common[@]}" \
            --field='Scroll direction:CB' "up!^down" \
            --field='Repetition:NUM' "1!1..30")"
          [ $? != 0 ] && return
          scroll_direction="$(echo "$output" | sed -n 1p)"
          repetition="$(echo "$output" | sed -n 2p)"
          
          clipboard_set "mouse_scroll_$scroll_direction $repetition"
          ;;
        move-mouse)
          output="$(yad "${yad_common[@]}" \
            --text="$default_text"$'\n'"<b><u>WARNING! Try to avoid using this.</u></b>"$'\n'"It's better to use <b>patterns</b> to position the mouse." \
            --field='Coordinates:' "0,0" \
            --field='Pick coordinates:FBTN' "@bash -c 'gui_pick_pixel_on_screen | sed s/^/1:/g'" \
            --field='Test it now:FBTN' 'bash -c "mouse_move %1"')"
          [ $? != 0 ] && return
          coordinates="$(echo "$output" | sed -n 1p)"
          
          clipboard_set "mouse_move $coordinates"
          ;;
        keyboard-type)
          output="$(yad "${yad_common[@]}" \
            --field='Text to type:TXT' "" )"
          [ $? != 0 ] && return
          text_to_type="$(echo "$output" | sed -n 1p | sed "s/'/\\\'/g")"
          
          clipboard_set "keyboard_type '$text_to_type'"
          ;;
        keyboard-shortcut)
          output="$(yad "${yad_common[@]}" \
            --text="$default_text"$'\n'"Choose up to 3 keys to be pressed while pressing normal keys." \
            --field='Special key 1:CB' "Ctrl!Shift!Alt!Super!Enter!Tab!Escape!Backspace!Space" \
            --field='Special key 2:CB' "!Ctrl!Shift!Alt!Super!Enter!Tab!Escape!Backspace!Space" \
            --field='Special key 3:CB' "!Ctrl!Shift!Alt!Super!Enter!Tab!Escape!Backspace!Space" \
            --field='Normal keys:' "")"
          [ $? != 0 ] && return
          keycombo="$(echo "$output" | head -n3 | tr '\n' ' ' | sed 's/  / /g ; s/ $//g')"
          normalkeys="$(echo "$output" | sed -n 4p)"
          if [ ! -z "$normalkeys" ];then
            #quote normal keys in single-quotes, and escape any single quotes
            keycombo+=" '$(echo "$normalkeys" | sed "s/'/'\\\''/g")'"
          fi
          
          clipboard_set "keyboard_shortcut $keycombo"
          ;;
        set-clipboard)
          clipboard="$(yad "${yad_common[@]}" \
            --field='Text to copy:' '' \
            --field='Test it now:FBTN' 'bash -c "clipboard_set %1"')"
          [ $? != 0 ] && return
          echo "copying code: $clipboard"
          clipboard_set "clipboard_set '$(echo "$clipboard" | sed "s/'/'\\\''/g")'"
          ;;
      esac
    }
    #open the userscript in a text editor
    #text_editor "$USERSCRIPT" || exit 1
    yad "${yadflags[@]}" --title="Automaton script builder" --width=400 --height=500 --form --scroll \
      --text="Most of these buttons make short code snippets that drop into <a href="\""file://${USERSCRIPT}"\"">$(basename "${USERSCRIPT}")</a>." \
      --field="<big>Mouse &amp; Keyboard &amp; Clipboard</big>":LBL '' \
      --field="Click!!Simulates a normal mouse click":FBTN "bash -c 'draft_snippet click'" \
      --field="Right-click!!Simulates the mouse clicking its right button":FBTN "bash -c 'draft_snippet right-click'" \
      --field="Middle-click!!Simulates the mouse clicking its scroll wheel":FBTN "bash -c 'draft_snippet middle-click'" \
      --field="Scroll up/down!!Simulates the scroll wheel spinning":FBTN "bash -c 'draft_snippet scroll'" \
      --field="Move mouse!!Moves the mouse pointer to exact coordinates (0,0 is the top-left corner)":FBTN "bash -c 'draft_snippet move-mouse'" \
      --field="Type words!!Simulates the keyboard typing (ASCII characters only. Use <b>Set clipboard</b> for non-ASCII characters)":FBTN "bash -c 'draft_snippet keyboard-type'" \
      --field="Keyboard shortcut!!Presses combinations of keys, and other special keys":FBTN "bash -c 'draft_snippet keyboard-shortcut'" \
      --field="Set clipboard!!Copies the text of your choice to the clipboard":FBTN "bash -c 'draft_snippet set-clipboard'" \
      --field="<big>Patterns</big> (things to find on the screen)":LBL '' \
      --field="Pattern Manager!!Create/Rename/Edit/Delete patterns for this project":FBTN '' \
      --field="Wait for a pattern to appear!!Keeps checking for something specific appears on-screen, then proceeds":FBTN '' \
      --field="Do something until a pattern appears!!Repeatedly clicks/scrolls/types until something specific appears on-screen":FBTN '' \
      --field="Wait for a pattern, then click it!!Keeps checking for the chosen pattern to appear, then clicks it":FBTN '' \
      --field="If a pattern is already there, click it!!Checks once for a pattern, clicks it if found":FBTN '' \
      --field="Given 2 patterns, wait for one to appear!!Waits for 1 of 2 patterns to appear, behaves differently based on which one is spotted":FBTN '' \
      --field="<big>SubScreens</big> (a virtual screen keeps things organized)":LBL '' \
      --field="X11 subscreen (visible)!!Launches a windowed screen that all future steps will use":FBTN '' \
      --field="X11 subscreen (invisible)!!Starts a hidden screen that all future steps will use":FBTN '' \
      --field="Wayland subscreen (visible)!!Launches a windowed screen that all future steps will use":FBTN '' \
      --field="Wayland subscreen (invisible)!!Starts a hidden screen that all future steps will use":FBTN '' \
      --field="Stop a running subscreen!!Makes all future steps run in your primary screen":FBTN '' \
      --field="<big>Assistance and debugging</big>":LBL '' \
      --field="Open an issue!!Report a bug or ask for help":FBTN 'x-www-browser https://github.com/Botspot/automaton/issues' \
      --field="Ask AI for scripting help!!Copies a prompting template for an anonymized ChatGPT to help you effectively use Automaton's features":FBTN 'bash -c "ask_ai"' \
      --field="Check script for syntax errors!!Analyzes the script with shellcheck ":FBTN "$AUTOMATON_DIR/terminal-run "\""shellcheck '${USERSCRIPT}';echo 'Press Enter to exit.';read enter"\"" "\""Automaton Shellcheck for $(basename '${USERSCRIPT}')"\""" \
      --field="Run script in debug mode (bash -x)!!Shows every command ran by $(basename "${USERSCRIPT}")":FBTN "bash -c 'test_userscript debug'" \
      --button="Run Script":"bash -c test_userscript"
    exit 0
    ;;
  make-new-pattern)
    #use an existing screenshot to make a new pattern from it
    screenshot="$(gui_screenshot_picker)" || exit 1
    pattern="$(gui_make_pattern "$screenshot")" || exit 1
    ;;
  make-old-pattern)
    #re-select an existing pattern
    pattern="$(gui_pattern_picker)" || exit 1
    screenshot="$(gui_screenshot_picker)" || exit 1
    gui_make_pattern "$screenshot" "$pattern" >/dev/null || exit 1
    ;;
  test-pattern-live)
    gui_test_pattern_live geany-newfile.png
    ;;
  
esac
done

