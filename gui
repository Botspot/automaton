#!/bin/bash

AUTOMATON_DIR="$(readlink -f "$(dirname "$0")")"

source "$AUTOMATON_DIR/api" || exit 1

#functions defined below are not available to userscripts.
gui_pick_region() { #use region-picker.py to pick a rectangular region of the $1 image, outputs rectangle coordinates (X,Y +W+H)
  if [ ! -f "$1" ];then
    error "gui_pick_region(): provided image '$1' does not exist!"
  fi
  "${AUTOMATON_DIR}/region-picker.py" "$1" rectangle
}

gui_pick_pixel() { #use region-picker.py to pick a pixel of the $1 image, outputs coordinates (X,Y)
  if [ ! -f "$1" ];then
    error "gui_pick_pixel(): provided image '$1' does not exist!"
  fi
  "${AUTOMATON_DIR}/region-picker.py" "$1" pixel
}

gui_pick_pixel_on_screen() { #uses a temporary screenshot, outputs coordinates (X,Y)
  local screenshot="$RAM_LOCATION/automaton-gui_pick_pixel_on_screen.png"
  
  screenshot_fullscreen "$screenshot" || return 1
  gui_pick_pixel "$screenshot" || return 1
  rm -f "$screenshot"
}

gui_pick_pattern_offset() { #Prompt user to choose a point relative to a pattern. Uses original screenshot if possible. input: $1=pattern, outputs offset (+X+Y)
  local pattern="$1"
  if [ ! -f "$PATTERNS_DIR/$pattern" ];then
    error "gui_pick_pattern_offset(): pattern png file at '$PATTERNS_DIR/$pattern' not found!"
  fi
  
  #hopefully nobody includes regex characters in a pattern name
  local screenshot_regions_line="$(grep "^$pattern\t" "$PATTERNS_DIR/screenshot-regions.tsv" 2>/dev/null | tail -1)"
  if [ ! -z "$screenshot_regions_line" ];then
    #found screenshot name and cropped region
    screenshot="$(echo "$screenshot_regions_line" | awk -F'\t' '{print $2}')"
    region="$(echo "$screenshot_regions_line" | awk -F'\t' '{print $3}')"
    
    #if data is invalid, fallback to picking a region only within the pattern
    if [ -z "$screenshot" ] || [ -z "$region" ] || [ ! -f "$SCREENSHOTS_CACHE/$screenshot" ];then
      screenshot_regions_line=''
    fi
  fi
  if [ ! -z "$screenshot_regions_line" ];then
    #display region in a rectangle, over the original screenshot used to make this pattern, to pick a pixel
    offset="$("${AUTOMATON_DIR}/region-picker.py" "$SCREENSHOTS_CACHE/$screenshot" pixel_in_rectangle "$region")"
  else
    #fallback to only display the pattern, pick a pixel on it, and convert x,y coordinates to +x+y
    warning "gui_pick_pattern_offset(): could not find a screenshot and/or region that corresponds to '$pattern'. Please make corrections to the screenshots cache at $SCREENSHOTS_CACHE, and '$PATTERNS_DIR/screenshot-regions.tsv'."
    offset="$("${AUTOMATON_DIR}/region-picker.py" "$PATTERNS_DIR/$pattern" pixel | sed 's/^/+/g ; s/,/+/g')"
  fi
  
  echo "$offset"
}

generate_thumbnail() { #convert full size screenshot filename (already in cache) and shrink it for thumbnail folder
  local filename="$1"
  if [ ! -f "$SCREENSHOTS_CACHE/$filename" ];then
    error "generate_thumbnail(): file '$SCREENSHOTS_CACHE/$filename' does not exist!"
  elif [ -f "$THUMBNAILS_CACHE/$filename" ];then
    #if thumbnail already exists, remove it first
    rm "$THUMBNAILS_CACHE/$filename"
  fi
  convert "$SCREENSHOTS_CACHE/$filename" -resize 25% "$THUMBNAILS_CACHE/$filename"
}

rename_screenshot() { #rename $1 filename to $2
  local filename="$1"
  local destination="$2"
  if [ ! -f "$SCREENSHOTS_CACHE/$filename" ];then
    error "rename_screenshot(): file '$SCREENSHOTS_CACHE/$filename' does not exist!"
  elif [ -z "$destination" ];then
    error "rename_screenshot(): destination filename not specified!"
  elif [ -f "$SCREENSHOTS_CACHE/$destination" ];then
    error "rename_screenshot(): refusing to overwrite '$SCREENSHOTS_CACHE/$destination'"
  fi
  
  mv -f "$SCREENSHOTS_CACHE/$filename" "$SCREENSHOTS_CACHE/$destination"
  mv -f "$THUMBNAILS_CACHE/$filename" "$THUMBNAILS_CACHE/$destination"
}

remove_screenshot() { #delete the $1 screenshot
  rm -f "$SCREENSHOTS_CACHE/$1" "$THUMBNAILS_CACHE/$1"
}

gui_capture_screenshot() { #take a fullscreen screenshot, name it, save to cache, save thumbnail, echo filename
  local date="$(date +"%Y-%m-%d %X")"
  screenshot_fullscreen "$SCREENSHOTS_CACHE/$date.png"
  generate_thumbnail "$date.png"
  
  #now ask the user what to name the screenshot
  local final_filename button
  local text="Screenshot captured. Choose a unique name:"
  while true;do
    final_filename="$(yad "${yadflags[@]}" --image="$THUMBNAILS_CACHE/$date.png" --image-on-top \
      --form --field="$text:LBL" "" \
      --field='' "$date" --button=Cancel:1 --button=OK:0)"
    button=$?
    final_filename="$(echo "$final_filename" | tail -n +2).png"
    if [ $button != 0 ];then
      remove_screenshot "$date.png"
      error "User exited screenshot naming dialog" #user cancelled the dialog
    elif [ "$final_filename" == "$date.png" ];then
      #user did not rename the file, so leave it as-is
      break
    elif [ -f "$THUMBNAILS_CACHE/$final_filename" ];then
      text="That name is already taken."$'\n'"$text"
    elif [ "$final_filename" == '.png' ];then
      text="Name cannot be left blank."$'\n'"$text"
    else
      #user chose a valid unique filename
      rename_screenshot "$date.png" "$final_filename"
      break
    fi
  done
  
  echo "$final_filename"
}

gui_screenshot_picker() { #pick a screenshot from the automaton cache. outputs a filename.
  local IFS=$'\n'
  local button
  local first_loop=1
  
  #add a new screenshot buttons before looping through existing screenshots
  (echo "New screenshot
Capture a new screenshot when clicked
${AUTOMATON_DIR}/icons/new-screenshot.png
bash -c "\""kill "\$"YAD_PID; yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n'); sleep 1; gui_capture_screenshot"\""
FALSE
New screenshot (5s delay)
Capture a new screenshot 5 seconds after clicking this
${AUTOMATON_DIR}/icons/new-screenshot.png
bash -c "\""kill "\$"YAD_PID; yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n'); sleep 5; gui_capture_screenshot"\""
FALSE"
  find "$SCREENSHOTS_CACHE" -name '*.png' | sort | sed 's+.*/++g' | while read filename ;do
    
    #generate thumbnail for this screenshot if it somehow went missing
    if [ ! -f "$THUMBNAILS_CACHE/$filename" ];then
      generate_thumbnail "$filename" >/dev/null
    fi
    echo "$filename
$(identify -ping -format '%wx%h PNG image' "$SCREENSHOTS_CACHE/$filename")
$THUMBNAILS_CACHE/$filename
bash -c "\""echo $filename; kill "\$"YAD_PID"\""
FALSE"
  done) | yad "${yadflags[@]}" --maximized --icons --listen --item-width 100 --single-click --no-buttons --text="Choose a screenshot:"
  button=$?
  if [ $button != 0 ] && [ $button != 143 ];then
    error "User exited gui_screenshot_picker"
  fi
}

gui_pattern_picker() { #pick a pattern from this project's PATTERNS_DIR. outputs a filename.
  local button
  
  #add a new pattern button before looping through existing patterns
  (echo "New pattern from screenshot
Crop a region from a screenshot to make a new pattern
${AUTOMATON_DIR}/icons/new-pattern.png
bash -c 'kill "\$"YAD_PID; yadflags=(--center --separator="\""\n"\""); gui_make_pattern "\"\$"(gui_screenshot_picker)"\""'
FALSE"
  find "$PATTERNS_DIR" -name '*.png' | sort | sed 's+.*/++g' | while read filename ;do
    
    echo "$filename
$(identify -ping -format '%wx%h PNG image' "$PATTERNS_DIR/$filename")
$PATTERNS_DIR/$filename
bash -c "\""echo $filename; kill "\$"YAD_PID"\""
FALSE"
  done) | yad "${yadflags[@]}" --maximized --icons --listen --item-width 100 --single-click --no-buttons --text="Choose a pattern:"
  button=$?
  if [ $button != 0 ] && [ $button != 143 ];then
    error "User exited gui_pattern_picker"
  fi
}

gui_pattern_manager() { #Test/Edit/Rename/Delete patterns in $PATTERNS_DIR
  while true;do
    output="$(find "$PATTERNS_DIR" -name '*.png' | sort | sed 's+.*/++g' | \
    while read filename ;do
      echo "$PATTERNS_DIR/$filename"$'\n'"$filename"
    done | yad "${yadflags[@]}" --title "Automaton Pattern Manager" --width 450 --height=300 --list --no-headers --column=:IMG --column=Name --listen --item-width 100 --single-click \
      --text="Select a pattern, then choose an action to apply to it." \
      --button="Cancel!!Exit Pattern Manager:1" \
      --button="Delete!!Remove this pattern:6" \
      --button="Rename!!Keep this pattern but change its filename:2" \
      --button="Edit!!Choose any screenshot and a region to crop for this pattern:4" \
      --button="Test!!Monitor in real time if the pattern is found on the screen:0" )"
    button=$?
    pattern="$(echo "$output" | sed -n 2p)"
    if [ -z "$pattern" ];then
      error "gui_pattern_manager(): user exited without selecting anything"
    fi
    case $button in
      0) #test
        gui_test_pattern_live "$pattern"
        ;;
      2) #rename
        new_name="$(yad "${yadflags[@]}" --entry --entry-text="$pattern" --text="Choose a new name for <u>$pattern</u>")"
        button=$?
        if [ "$button" != 0 ];then
          true #user clicked Cancel
        elif [[ "$new_name" != *.png ]];then
          #ensure new name ends in .png
          new_name+='.png'
        fi
        mv -f "$PATTERNS_DIR/$pattern" "$PATTERNS_DIR/$new_name"
        #change entry in the references spreadsheet
        sed -i "s/^$pattern\t/$new_name\t/g" "$PATTERNS_DIR/screenshot-regions.tsv"
        ;;
      4) #edit - recreate the pattern from a screenshot - keep original name
        gui_make_pattern "$(gui_screenshot_picker)" "$pattern"
        ;;
      6) #delete pattern
        sed -i "/^$final_filename\t/d" "$PATTERNS_DIR/screenshot-regions.tsv"
        rm -f "$PATTERNS_DIR/$pattern"
        ;;
    esac
  done
}

gui_make_pattern() { #from the $1 screenshot filename, prompt user to crop it, name it if $2 is blank, and output that filename
  local filename="$1"
  local screenshot="$SCREENSHOTS_CACHE/$filename"
  if [ -z "$filename" ];then
    error "gui_make_pattern(): needs a screenshot filename to do anything"
  elif [ ! -f "$screenshot" ];then
    error "gui_make_pattern(): file '$screenshot' does not exist!"
  fi
  local final_filename="$2" #optional argument to skip the naming dialog (overwriting allowed)
  
  local region
  region="$(gui_pick_region "$screenshot")" || return 1
  crop_image "$screenshot" "$region" "$RAM_LOCATION/automaton-new-pattern.png" || return 1
  
  #now ask the user what to name the pattern
  local button
  local text="Choose a unique name for this pattern:"
  while [ -z "$final_filename" ];do
    final_filename="$(yad "${yadflags[@]}" --image="$RAM_LOCATION/automaton-new-pattern.png" --image-on-top \
      --form --field="$text:LBL" "" \
      --field='' "$(echo "$filename" | sed 's/\.png$//g')" --button=OK:0 | tail -n +2 ; exit ${PIPESTATUS[0]}).png"
    button=$?
    if [ $button != 0 ];then
      error "User exited pattern naming dialog" #user cancelled the dialog
    elif [ -f "$PATTERNS_DIR/$final_filename" ];then
      text="That name is already taken."$'\n'"$text"
      final_filename=''
    elif [ "$final_filename" == '.png' ];then
      text="Name cannot be left blank."$'\n'"$text"
      final_filename=''
    else
      #user chose a valid unique filename, loop will exit
      true
    fi
  done
  #name the pattern
  mv -f "$RAM_LOCATION/automaton-new-pattern.png" "$PATTERNS_DIR/$final_filename" || error "Failed to move pattern to $PATTERNS_DIR/$final_filename"
  
  #record screenshot name and cropped region for pixel picking later
  if [ ! -f "$PATTERNS_DIR/screenshot-regions.tsv" ];then
    #initialize the file by naming the columns
    echo -e "pattern filename\tscreenshot filename\tcrop region" > "$PATTERNS_DIR/screenshot-regions.tsv"
  else
    #file already exists, so in case this pattern is being recreated, remove any references to it first
    sed -i "/^$final_filename\t/d" "$PATTERNS_DIR/screenshot-regions.tsv"
  fi
  echo "$final_filename"$'\t'"$filename"$'\t'"$region" >> "$PATTERNS_DIR/screenshot-regions.tsv"
  echo "$final_filename"
}

gui_test_pattern_live() { #indicate in real-time if pattern $1 is seen on screen or not.
  #pattern="$(gui_pattern_picker)" || exit 1
  local pattern="$1"
  local offset="$2"
  if [ ! -f "$PATTERNS_DIR/$pattern" ];then
    error "locate_pattern(): pattern png file at '$PATTERNS_DIR/$pattern' not found!"
  elif [ -z "$offset" ];then
    offset='+0+0'
  fi
  
  locator_start
  
  local IFS=' '
  local history=''
  while true;do
    if output="$(locate_pattern "$pattern" "$offset")" ;then
      read coordinates similarity <<<"$output"
      similarity="$(echo "$similarity" | tr -cd '0123456789')"
      found='✅ Yes'
      history="▰$history"
    else
      found='❌ No'
      coordinates=' '
      similarity='0'
      history="▱$history"
    fi
    
    #truncate length of history
    history="${history:0:40}"
    
    echo "coordinates: $coordinates similarity $similarity" 1>&2
    #refresh the yad window with these new values
    echo "$history
$found
$coordinates
$similarity
bash -c 'mouse_move $coordinates'"
    
  done | yad "${yadflags[@]}" --width=400 --text="Watching screen for pattern: <u><b>$pattern</b></u>" \
    --form --focus-field=3 --cycle-read --button=Close:0 \
    --field='Past results::RO' --field='Pattern found?:RO' --field=Coordinates: \
    --field='Similarity::SCL' --field='Move mouse to pattern':FBTN
}

text_editor() { #Open user-preferred text editor. $1 is file to open (function adapted from Pi-Apps)
  if [ -z "$1" ];then
    error "text_editor(): no file specified"
  fi
  
  #find the best text editor
  local preferrededitor="$(cat "$AUTOMATON_CONFIG/text-editor" 2>/dev/null || echo geany)"
  # map friendly name of editors to binary name
  if [ "$preferrededitor" == "Visual Studio Code" ];then
    preferrededitor="code"
  elif [ "$preferrededitor" == "VSCodium" ];then
    preferrededitor="codium"
  fi
  
  #change preferred editor if user-default doesn't exist
  if ! command -v "$preferrededitor" >/dev/null;then
    preferrededitor=geany
  fi
  if ! command -v "$preferrededitor" >/dev/null;then
    preferrededitor=mousepad
  fi
  if ! command -v "$preferrededitor" >/dev/null;then
    preferrededitor=leafpad
  fi
  if ! command -v "$preferrededitor" >/dev/null;then
    local errormessage="text_editor(): could not detect any installed text editing programs on your system! Please install something like leafpad, mousepad, or geany. If you have a favorite text editor that is not detected, open an issue and it can be added to the list."
    yad --text="$errormessage" --button=OK:0
    error "$errormessage"
  fi
  
  #non-terminal text editor
  "$preferrededitor" "$1" &
}

update_check() { #check for updates and reload the script if necessary
  localhash="$(cd "$DIRECTORY" ; git rev-parse HEAD)"
  latesthash="$(git ls-remote https://github.com/Botspot/automaton HEAD | awk '{print $1}')"
  if [ "$localhash" != "$latesthash" ] && [ ! -z "$latesthash" ] && [ ! -z "$localhash" ];then
    if [ "$disable_updates" == true ];then
      echo "Updates available, but you have auto-updates disabled."
      return 0
    fi
    echo "Auto-updating Automaton for the latest features and improvements..."
    (cd "$DIRECTORY"
    git restore . #abandon changes to tracked files (otherwise users who modified this script are left behind)
    git -c color.ui=always pull | cat #piping through cat makes git noninteractive
    return "${PIPESTATUS[0]}")
    
    if [ $? == 0 ];then
      echo "git pull finished. Reloading script..."
      "$AUTOMATON_DIR/gui" "${original_flags[@]}"
      exit $?
    else
      warning "update_check: git pull failed. Continuing..."
    fi
  fi
}

#Track the original arguments given to the script in order to restart in an update
original_flags=("$@")

AUTOMATON_CONFIG=~/.config/automaton
SCREENSHOTS_CACHE="${AUTOMATON_CONFIG}/screenshots"
THUMBNAILS_CACHE="${AUTOMATON_CONFIG}/thumbnails"
mkdir -p "$SCREENSHOTS_CACHE" "$THUMBNAILS_CACHE" || error "Making cache folder failed, please review errors above"

#this needs to be set because api is sourced before PATTERNS_DIR is set, making the previous value /locator_pipe
locator_pipe="$AUTOMATON_CONFIG/locator_pipe"

yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n')

#check for updates
update_check

mode="$1"
mode=choose-project
while true;do
case "$mode" in
  choose-project) #project creation, selection, and onboarding
    
    #recall previous choices using a 2-line config file
    current_project_config_file="$AUTOMATON_CONFIG/current-project"
    if [ -f "$current_project_config_file" ];then
      USERSCRIPT="$(sed -n 1p "$current_project_config_file")"
      PATTERNS_DIR="$(sed -n 2p "$current_project_config_file")"
      if [ ! -f "$USERSCRIPT" ];then
        USERSCRIPT=''
      fi
      if [ ! -d "$PATTERNS_DIR" ];then
        PATTERNS_DIR=''
      fi
    fi
    
    interpret_patterns_dir_from_script() { #read the specified automaton script and try to find the path to the PATTERNS_DIR it is using. Output: folder path, and exit code 1 if it does not exist
      [ ! -f "$1" ] && error "interpret_patterns_dir_from_script(): script '$1' not found"
      local PATTERNS_DIR="$(grep -m1 -o 'PATTERNS_DIR=.*' "$1" | sed 's/#.*//g ; s+~/+'$HOME/'+g ; s+$HOME+'$HOME'+g ; s/^PATTERNS_DIR=//g ; s/^"//g ; s/"$//g')"
      echo "$PATTERNS_DIR" #send the interpreted PATTERNS_DIR to stdout
      [ -d "$PATTERNS_DIR" ] #return code 0 if found, otherwise return 1
    }
    
    yad_new_project_wizard() { #just for choose-project mode, this returns paths to script and patterns folders
      yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n')
      text="This <b>script</b> will perform automated tasks of your choosing. Choose a good place to save it."
      while true;do
        USERSCRIPT="$(cd $HOME/Documents; yad "${yadflags[@]}" --maximized --text="$text" --file --save \
          --filename=project1.sh --file-filter="Bash script | *.sh" \
          --confirm-overwrite="If you proceed with this file, its contents will be replaced with a few lines of template code. Are you sure?")"
        button=$?
        if [ "$button" != 0 ];then
          error "user exited project script naming dialog"
        elif [[ "$USERSCRIPT" != *'.sh' ]];then
          text+=$'\n'"Project script must end in .sh"
        else
          break
        fi
      done
      text="<b>Patterns</b> are small pictures that tell the script what to find on the screen. Choose a folder to store them."
      while true;do
        PATTERNS_DIR="$(cd "$(dirname "$USERSCRIPT")"; yad "${yadflags[@]}" --maximized --text="$text" --filename="$(basename "$USERSCRIPT" | sed 's/\.sh$/-patterns/g')" --file --directory --save)"
        button=$?
        if [ "$button" != 0 ];then
          error "user exited project folder naming dialog"
        else
          break
        fi
      done
      #send these values to yad's form fields
      echo "3:$USERSCRIPT" | sed "s+$HOME+~+g"
      echo "4:$PATTERNS_DIR" | sed "s+$HOME+~+g"
    }
    yad_existing_project_wizard() { #just for choose-project mode, this returns paths to script and patterns folders
      yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n')
      text="Choose a previously created Automaton script."
      while true;do
        USERSCRIPT="$(cd $HOME/Documents; yad "${yadflags[@]}" --maximized --text="$text" --file \
          --filename=project1.sh --file-filter="Bash scripts | *.sh")"
        button=$?
        if [ "$button" != 0 ];then
          error "user exited project script choosing dialog"
        elif ! grep -q 'PATTERNS_DIR=' "$USERSCRIPT" ;then
          yad "${yadflags[@]}" --text="<u>$USERSCRIPT</u>"$'\n'"That file does not mention 'PATTERNS_DIR=' anywhere. All Automaton projects must clearly reference the folder for storing patterns."$'\n'"Please fix the file or choose a different one." --button=OK
          error "That file does not mention 'PATTERNS_DIR=' anywhere."
        else
          
          if PATTERNS_DIR="$(interpret_patterns_dir_from_script "$USERSCRIPT")" ;then
            #script interpreted successfully, choose this PATTERNS_DIR
            break
          else
            yad "${yadflags[@]}" --text="Failed to interpret the the PATTERNS_DIR= line in the script. This folder does not exist: <u>${PATTERNS_DIR}</u>"$'\n'"Please fix the file or choose a different one."
            error "Failed to interpret the the PATTERNS_DIR= line in the script. This folder does not exist: '${PATTERNS_DIR}'"
          fi
          
        fi
      done
      #send these values to yad's form fields
      echo "3:$USERSCRIPT" | sed "s+$HOME+~+g"
      echo "4:$PATTERNS_DIR" | sed "s+$HOME+~+g"
    }
    
    output="$(yad "${yadflags[@]}" --width=400 --form \
      --field='New Automaton project':FBTN "@bash -c 'yad_new_project_wizard'" \
      --field='Choose existing project':FBTN "@bash -c 'yad_existing_project_wizard'" \
      --field='Script::RO' "$(echo "$USERSCRIPT" | sed "s+$HOME+~+g")" \
      --field='Patterns Folder::RO' "$(echo "$PATTERNS_DIR" | sed "s+$HOME+~+g")" \
      --button='Open this project':0)"
    USERSCRIPT="$(echo "$output" | sed -n 3p | sed "s+~+$HOME+g")"
    PATTERNS_DIR="$(echo "$output" | sed -n 4p | sed "s+~+$HOME+g")"
    
    #save new values to config file for next time
    echo "$USERSCRIPT"$'\n'"$PATTERNS_DIR" > "$current_project_config_file"
    
    #initialize script if necessary
    if [ ! -f "$USERSCRIPT" ] || ! interpret_patterns_dir_from_script "$USERSCRIPT" >/dev/null ;then
      #script invalid or does not exist, so make it
      if [ -f "$USERSCRIPT" ] && [ ! -f "$USERSCRIPT.bak" ];then
        #if it exists already, then move to backup location
        status "Saving a backup of pre-existing script '$USERSCRIPT' to '$USERSCRIPT.bak'..."
        mv -f "$USERSCRIPT" "$USERSCRIPT.bak"
      fi
      rm -f "$USERSCRIPT" || error "Failed to first remove '$USERSCRIPT'"
      echo "#!/bin/bash

#folder that contains the patterns to be used by this script
PATTERNS_DIR=$(echo '"'"$PATTERNS_DIR"'"' | sed "s+"\""$HOME+"\"\$"HOME+g")

#get access to automaton's bash functions, including locate_pattern and mouse_move
AUTOMATON_DIR=$(echo '"'"$AUTOMATON_DIR"'"' | sed "s+"\""$HOME+"\"\$"HOME+g")
source "\"\$"AUTOMATON_DIR/api"\""

#this starts the pattern locator service. Comment this out if you don't use locate_pattern.
locator_start

#Your code begins below this line. Happy automating! -Botspot" > "$USERSCRIPT"
      #make the script executable
      chmod +x "$USERSCRIPT"
      #make the patterns directory
      mkdir -p "$PATTERNS_DIR"
    fi
    #set the next mode to use after this
    mode=userscript-editor
    ;;
  userscript-editor) #main gui where the user sets up their script
    if [ ! -f "$USERSCRIPT" ] || [ ! -d "$PATTERNS_DIR" ];then
      error "userscript-editor mode requires valid values for USERSCRIPT and PATTERNS_DIR."
    fi
    export USERSCRIPT
    #functions to be used by yad in userscript-editor mode:
    ask_ai() { #opens a browser to duck.ai, and provides a premade prompt
      yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n')
      
      ai_text_payload="I need help bash scripting on a $(cat /etc/os-release | grep PRETTY_NAME | tr -d '"' | awk -F= '{print $2}') Linux distro.
Please assume I have little scripting experience, so make explanations beginner-friendly. Use code tags. Do not write lengthy summaries at the end of your answers.
The script in question is named \`${USERSCRIPT}\` and is intended to automate graphical tasks in the $XDG_SESSION_TYPE desktop environment, using shell functions provided by the Automaton project on github. https://github.com/Botspot/automaton
Below is all Automaton functions. This list was generated with: \`grep -F '() {' "\""$AUTOMATON_DIR/api"\""\`.
\`\`\`
$(grep -F '() {' "$AUTOMATON_DIR/api")
\`\`\`
Important notes:
- AUTOMATON_DIR=$AUTOMATON_DIR - path to the automaton git repo, which contains api, gui, and other automaton helper scripts.
- PATTERNS_DIR=$PATTERNS_DIR - path to folder that stores PNG files (patterns) used by the locate_pattern function.
- Automaton's strength is its pattern recognition. Use it to move the mouse. Don't use hardcoded coordinate values.
- All Automaton functions work the same in x11 and wayland.
- All automaton functions expect a relative filename for patterns in PATTERNS_DIR. Don't use full path, don't add logic to check if a pattern png file exists.
- Don't sleep X seconds to wait for an app or website to open. Simply use locate_pattern_retry to wait for something in that app/website to appear on screen.
- To open a website, use chromium <website-url> &
Bad:
mouse_move 800,400
Good:
mouse_move $(locate_pattern_retry button-3.png center)
Below is the current contents of \`${USERSCRIPT}\`:
\`\`\`bash
$(cat "${USERSCRIPT}")
\`\`\`
Start your initial response with "\""<name of ai model> here. I am good at bash scripting and am familiar with Automaton's features."\"" Then if there is any further text after this sentence, that is my request and please respond to it.







"
      ai_text_payload="$(echo "$ai_text_payload" | yad "${yadflags[@]}" --text-info --tail --editable --wrap --back=black --fore='#00AAFF' \
        --text="<big>To get the best AI assistance, this text should be pasted into the beginning of your chat.</big>"$'\n'"<b>Add your question to the end, then proceed.</b>" \
        --button="<big>Copy text and launch AI chat window</big>":0)"
      button=$?
      if [ "$button" == 0 ] && [ ! -z "$ai_text_payload" ];then
        clipboard_set "$ai_text_payload"
        
        #opens a browser to duck.ai
        echo 'opening browser...'
        x-www-browser "https://duckduckgo.com/?q=DuckDuckGo+AI+Chat&ia=chat&duckai=1" &
      fi
    }
    
    test_userscript() { #run $USERSCRIPT in a visible terminal, add $1=debug for debug mode
      if [ "$1" == debug ];then
        "$AUTOMATON_DIR/terminal-run" "bash -x ${USERSCRIPT};echo 'Press Enter to exit.';read enter" "Running Automaton project in debug mode: $(basename ${USERSCRIPT})"
      else
        "$AUTOMATON_DIR/terminal-run" "${USERSCRIPT};echo 'Press Enter to exit.';read enter" "Running Automaton project: $(basename ${USERSCRIPT})"
      fi
    }
    
    draft_snippet() { #handles all GUI code snippet generators
      set -a
      default_text="Customize the behavior of this code snippet, then paste it into your script."
      yadflags=(--title=Automaton --class=automaton --name=automaton --center --separator='\n')
      yad_common=("${yadflags[@]}" --form --text="$default_text" \
        --button="Copy code!!Then paste it into $(basename "${USERSCRIPT}")":0)
      
      mode="$1"
      case "$mode" in
        click|right-click|middle-click) #user wants a click function added to their script
          output="$(yad "${yad_common[@]}" \
            --field='Click type:CB' "$mode!$(echo -en 'click\nright-click\nmiddle-click' | grep -vx "$mode" | tr '\n' '!' | sed 's/!$//g')" \
            --field='Repetition:CB' "single click!double-click")"
          [ $? != 0 ] && return
          function_name="mouse_$(echo "$output" | sed -n 1p | tr '-' '_')"
          repetition="$(echo "$output" | sed -n 2p)"
          if [ "$repetition" == 'single click' ];then
            clipboard_set "$function_name"
          elif [ "$repetition" == 'double-click' ];then
            clipboard_set "$function_name"$'\n'"sleep 0.2"$'\n'"$function_name"
          fi
          ;;
        scroll)
          output="$(yad "${yad_common[@]}" \
            --field='Scroll direction:CB' "up!^down" \
            --field='Repetition:NUM' "1!1..30")"
          [ $? != 0 ] && return
          scroll_direction="$(echo "$output" | sed -n 1p)"
          repetition="$(echo "$output" | sed -n 2p)"
          
          clipboard_set "mouse_scroll_$scroll_direction $repetition"
          ;;
        move-mouse)
          output="$(yad "${yad_common[@]}" \
            --text="$default_text"$'\n'"<b><u>WARNING! Try to avoid using this.</u></b>"$'\n'"It's better to use <b>patterns</b> to position the mouse." \
            --field='Coordinates:' "0,0" \
            --field='Pick coordinates:FBTN' "@bash -c 'gui_pick_pixel_on_screen | sed s/^/1:/g'" \
            --field='Test it now:FBTN' 'bash -c "mouse_move %1"')"
          [ $? != 0 ] && return
          coordinates="$(echo "$output" | sed -n 1p)"
          
          clipboard_set "mouse_move $coordinates"
          ;;
        keyboard-type)
          output="$(yad "${yad_common[@]}" \
            --field='Text to type:TXT' "" )"
          [ $? != 0 ] && return
          text_to_type="$(echo "$output" | sed -n 1p | sed "s/'/\\\'/g")"
          
          clipboard_set "keyboard_type '$text_to_type'"
          ;;
        keyboard-shortcut)
          output="$(yad "${yad_common[@]}" \
            --text="$default_text"$'\n'"Choose up to 3 keys to be pressed while pressing normal keys." \
            --field='Special key 1:CB' "Ctrl!Shift!Alt!Super!Enter!Tab!Escape!Backspace!Space" \
            --field='Special key 2:CB' "!Ctrl!Shift!Alt!Super!Enter!Tab!Escape!Backspace!Space" \
            --field='Special key 3:CB' "!Ctrl!Shift!Alt!Super!Enter!Tab!Escape!Backspace!Space" \
            --field='Normal keys:' "")"
          [ $? != 0 ] && return
          keycombo="$(echo "$output" | head -n3 | tr '\n' ' ' | sed 's/  / /g ; s/ $//g')"
          normalkeys="$(echo "$output" | sed -n 4p)"
          if [ ! -z "$normalkeys" ];then
            #quote normal keys in single-quotes, and escape any single quotes
            keycombo+=" '$(echo "$normalkeys" | sed "s/'/'\\\''/g")'"
          fi
          
          clipboard_set "keyboard_shortcut $keycombo"
          ;;
        set-clipboard)
          clipboard="$(yad "${yad_common[@]}" \
            --field='Text to copy:' '' \
            --field='Test it now:FBTN' 'bash -c "clipboard_set %1"')"
          [ $? != 0 ] && return
          clipboard_set "clipboard_set '$(echo "$clipboard" | sed "s/'/'\\\''/g")'"
          ;;
        dump-clipboard)
          clipboard="$(yad "${yad_common[@]}")"
          [ $? != 0 ] && return
          clipboard_set "clipboard_dump"
          ;;
        pattern-wait)
          output="$(yad "${yad_common[@]}" \
            --text="$default_text"$'\n'"<b>Wait for a pattern to appear</b>" \
            --field='Choose pattern:FBTN' '@bash -c "gui_pattern_picker | sed s/^/2:/g"' \
            --field='Pattern:' '')"
          [ $? != 0 ] && return
          pattern="$(echo "$output" | sed -n 2p)"
          clipboard_set "locate_pattern_retry '$pattern'"
          ;;
        pattern-do-wait)
          output="$(yad "${yad_common[@]}" \
            --text="$default_text"$'\n'"<b>Repeat command until pattern appears</b>" \
            --field='Choose pattern:FBTN' '@bash -c "gui_pattern_picker | sed s/^/2:/g"' \
            --field='Pattern:' '' \
            --field='Command to repeat while waiting::CBE' "!mouse_click!mouse_scroll down!mouse_scroll up!keyboard_type 'message'")"
          [ $? != 0 ] && return
          pattern="$(echo "$output" | sed -n 2p)"
          repeat_command="$(echo "$output" | sed -n 3p)"
          [ -z "$repeat_command" ] && repeat_command="true # <-- this was added because bash requires loops to repeat at least 1 command."
          clipboard_set "while ! locate_pattern '$pattern' ;do"$'\n'"  $repeat_command"$'\n'"done"
          ;;
        pattern-wait-click)
          output="$(yad "${yad_common[@]}" \
            --text="$default_text"$'\n'"<b>Wait for a pattern, then click it</b>" \
            --field='Choose pattern:FBTN' '@bash -c "gui_pattern_picker | sed s/^/2:/g"' \
            --field='Pattern:' '' \
            --field='Choose offset!!Instead of the center of the pattern, choose an exact point to click:FBTN' '@bash -c "gui_pick_pattern_offset %2 | sed s/^/4:/g"' \
            --field='Offset:' 'center')"
          [ $? != 0 ] && return
          pattern="$(echo "$output" | sed -n 2p)"
          offset="$(echo "$output" | sed -n 4p)"
          clipboard_set "mouse_move "\$"(locate_pattern_retry '$pattern')"$'\n'"mouse_click"
          ;;
        pattern-check-once-click)
          output="$(yad "${yad_common[@]}" \
            --text="$default_text"$'\n'"<b>If a pattern is already there, click it</b>" \
            --field='Choose pattern:FBTN' '@bash -c "gui_pattern_picker | sed s/^/2:/g"' \
            --field='Pattern:' '' \
            --field='Choose offset!!Instead of the center of the pattern, choose an exact point to click:FBTN' '@bash -c "gui_pick_pattern_offset %2 | sed s/^/4:/g"' \
            --field='Offset:' 'center')"
          [ $? != 0 ] && return
          pattern="$(echo "$output" | sed -n 2p)"
          offset="$(echo "$output" | sed -n 4p)"
          clipboard_set "mouse_move "\$"(locate_pattern '$pattern') && mouse_click || true"
          ;;
        pattern-check-once-exit)
          output="$(yad "${yad_common[@]}" \
            --text="$default_text"$'\n'"<b>If a pattern is not already there, exit script</b>" \
            --field='Choose pattern:FBTN' '@bash -c "gui_pattern_picker | sed s/^/2:/g"' \
            --field='Pattern:' '' \
            --field='Exit behavior::CB' 'Exit if pattern is not found!Exit if pattern is found')"
          [ $? != 0 ] && return
          pattern="$(echo "$output" | sed -n 2p)"
          exit_behavior="$(echo "$output" | sed -n 3p)"
          if [ "$exit_behavior" == 'Exit if pattern is not found' ];then
            clipboard_set "if ! locate_pattern '$pattern' ;then"$'\n'"  exit 0"$'\n'"fi"
          elif [ "$exit_behavior" == 'Exit if pattern is found' ];then
            clipboard_set "if locate_pattern '$pattern' ;then"$'\n'"  exit 0"$'\n'"fi"
          fi
          ;;
        wait-for-1-of-2)
          output_suggested_commands() {
            echo "!exit 0!mouse_move "\$"(locate_pattern '$pattern' center) ; mouse_click!keyboard_type 'message'"
          }
          output="$(yad "${yad_common[@]}" \
            --text="$default_text"$'\n'"<b>Given 2 patterns, wait for one to appear</b>" \
            --field='Choose pattern 1:FBTN' '@bash -c '\''pattern="$(gui_pattern_picker)" ; echo "2:$pattern" ; echo -n 3: ; output_suggested_commands'\''' \
            --field='Pattern 1:' '' \
            --field='If pattern 1 is seen first::CBE' "!exit 0!keyboard_type 'message'" \
            --field='Choose pattern 2:FBTN' '@bash -c '\''pattern="$(gui_pattern_picker)" ; echo "5:$pattern" ; echo -n 6: ; output_suggested_commands'\''' \
            --field='Pattern 2:' '' \
            --field='If pattern 2 is seen first::CBE' "!exit 0!keyboard_type 'message'")"
          [ $? != 0 ] && return
          pattern1="$(echo "$output" | sed -n 2p)"
          pattern2="$(echo "$output" | sed -n 5p)"
          reaction1="$(echo "$output" | sed -n 3p)"
          reaction2="$(echo "$output" | sed -n 6p)"
          
          if [ -z "$reaction1" ] && [ -z "$reaction2" ];then
            #if neither pattern has an associated reaction, use a simple while loop
            clipboard_set "while ! locate_pattern '$pattern1' && ! locate_pattern '$pattern2' ;do"$'\n'"  true"$'\n'"done"
          else
            [ -z "$reaction1" ] && reaction1='#pattern 1 found, exit the loop'
            [ -z "$reaction2" ] && reaction2='#pattern 2 found, exit the loop'
            clipboard_set "while true;do
  if locate_pattern '$pattern1' ;then
    $reaction1
    break
  elif locate_pattern '$pattern2' ;then
    $reaction2
    break
  fi
done"
          fi
          ;;
        x11-subscreen|x11-headless-subscreen|wayland-subscreen|wayland-headless-subscreen)
          case "$mode" in
            x11-subscreen)
              default_text+=$'\n'"<b>X11 subscreen (visible)</b>"
              ;;
            x11-headless-subscreen)
              default_text+=$'\n'"<b>X11 subscreen (invisible)</b>"
              ;;
            wayland-subscreen)
              default_text+=$'\n'"<b>Wayland subscreen (visible)</b>"
              ;;
            wayland-headless-subscreen)
              default_text+=$'\n'"<b>Wayland subscreen (invisible)</b>"
              ;;
          esac
          dimensions="$(yad "${yad_common[@]}" \
            --text="$default_text" \
            --field='Subscreen dimensions::CBE' '1920x1080!1366x768')"
          [ $? != 0 ] && return
          clipboard_set "subscreen_start $(echo "$mode" | sed 's/-subscreen$//g') $dimensions"
          ;;
        subscreen-stop)
          yad "${yad_common[@]}" \
            --text="$default_text"$'\n'"<b>Stop a running subscreen</b>"
          [ $? != 0 ] && return
          clipboard_set "subscreen_stop"
          ;;
      esac
    }
    #open the userscript in a text editor
    text_editor "$USERSCRIPT" || exit 1
    yad "${yadflags[@]}" --title="Automaton script builder" --width=400 --height=500 --form --scroll \
      --text="Most of these buttons make short code snippets that drop into <a href="\""file://${USERSCRIPT}"\"">$(basename "${USERSCRIPT}")</a>." \
      --field="<big>Mouse &amp; Keyboard &amp; Clipboard</big>":LBL '' \
      --field="Mouse move!!Moves the mouse pointer to exact coordinates (0,0 is the top-left corner)":FBTN "bash -c 'draft_snippet move-mouse'" \
      --field="Mouse click!!Simulates a normal mouse click":FBTN "bash -c 'draft_snippet click'" \
      --field="Mouse scroll!!Simulates scrolling up or down":FBTN "bash -c 'draft_snippet scroll'" \
      --field="Keyboard type!!Simulates the keyboard typing (ASCII characters only. Use <b>Set clipboard</b> for non-ASCII characters)":FBTN "bash -c 'draft_snippet keyboard-type'" \
      --field="Keyboard shortcut!!Presses combinations of keys, and other special keys":FBTN "bash -c 'draft_snippet keyboard-shortcut'" \
      --field="Clipboard set!!Copies the text of your choice to the clipboard":FBTN "bash -c 'draft_snippet set-clipboard'" \
      --field="Clipboard dump!!Outputs what is currently copied to the clipboard":FBTN "bash -c 'draft_snippet dump-clipboard'" \
      --field="<big>Patterns</big> (things to find on the screen)":LBL '' \
      --field="Pattern Manager!!Test/Edit/Rename/Delete patterns in <u>$PATTERNS_DIR</u>":FBTN '' \
      --field="Wait for a pattern to appear!!Keeps checking until something specific appears on-screen, then proceeds":FBTN "bash -c 'draft_snippet pattern-wait'" \
      --field="Repeat command until pattern appears!!Repeatedly clicks/scrolls/types until something specific appears on-screen":FBTN "bash -c 'draft_snippet pattern-do-wait'" \
      --field="Wait for a pattern, then click it!!Keeps checking for the chosen pattern to appear, then clicks it":FBTN "bash -c 'draft_snippet pattern-wait-click'" \
      --field="If a pattern is already there, click it!!Checks once for a pattern, clicks it if found, proceeds otherwise":FBTN "bash -c 'draft_snippet pattern-check-once-click'" \
      --field="If a pattern is not already there, exit script!!Checks once for a pattern, exits the script if not found":FBTN "bash -c 'draft_snippet pattern-check-once-exit'" \
      --field="Given 2 patterns, wait for one to appear!!Waits for 1 of 2 patterns to appear, behaves differently based on which one is spotted":FBTN "bash -c 'draft_snippet wait-for-1-of-2'" \
      --field="<big>SubScreens</big> (a virtual screen keeps things organized)":LBL '' \
      --field="X11 subscreen (visible)!!Launches a windowed screen that all future steps will use":FBTN "bash -c 'draft_snippet x11-subscreen'" \
      --field="X11 subscreen (invisible)!!Starts a hidden screen that all future steps will use":FBTN "bash -c 'draft_snippet x11-headless-subscreen'" \
      --field="Wayland subscreen (visible)!!Launches a windowed screen that all future steps will use":FBTN "bash -c 'draft_snippet wayland-subscreen'" \
      --field="Wayland subscreen (invisible)!!Starts a hidden screen that all future steps will use":FBTN "bash -c 'draft_snippet wayland-headless-subscreen'" \
      --field="Stop a running subscreen!!Makes all future steps run in your primary screen":FBTN "bash -c 'draft_snippet subscreen-stop'" \
      --field="<big>Assistance and debugging</big>":LBL '' \
      --field="Open an issue!!Report a bug or ask for help":FBTN 'x-www-browser https://github.com/Botspot/automaton/issues' \
      --field="Ask AI for scripting help!!Copies a prompting template for an anonymized ChatGPT to help you effectively use Automaton's features":FBTN 'bash -c "ask_ai"' \
      --field="Check script for syntax errors!!Analyzes the script with shellcheck ":FBTN "$AUTOMATON_DIR/terminal-run "\""shellcheck '${USERSCRIPT}';echo 'Press Enter to exit.';read enter"\"" "\""Automaton Shellcheck for $(basename '${USERSCRIPT}')"\""" \
      --field="Run script in debug mode (bash -x)!!Shows every command ran by $(basename "${USERSCRIPT}")":FBTN "bash -c 'test_userscript debug'" \
      --button="Run Script":"bash -c test_userscript"
    exit 0
    ;;
  make-new-pattern)
    #use an existing screenshot to make a new pattern from it
    screenshot="$(gui_screenshot_picker)" || exit 1
    pattern="$(gui_make_pattern "$screenshot")" || exit 1
    ;;
  make-old-pattern)
    #re-select an existing pattern
    pattern="$(gui_pattern_picker)" || exit 1
    screenshot="$(gui_screenshot_picker)" || exit 1
    gui_make_pattern "$screenshot" "$pattern" >/dev/null || exit 1
    ;;
  test-pattern-live)
    gui_test_pattern_live geany-newfile.png
    ;;
  
esac
done

