#!/bin/bash

#export all functions and variables so they are reachable by bash subprocesses, such as in timeout and yad
set -a

#DO NOT use set -e. It breaks any function that needs to run a command (like yad) and check its error code with $?

#Make trap payload that exits out of parent function that ran error
set -o functrace #Ensure DEBUG trap is inherited in functions

# Set DEBUG trap to exit from only the parent function that ran error, not any outer function layers
exiting_parent_function_from_error=0 #make variable global so changes made from within the error function persist
trap 'if [ "$exiting_parent_function_from_error" == 1 ] && [ ${#FUNCNAME[@]} -gt 1 ] && [ "${FUNCNAME[1]}" != "source" ] && [ "${FUNCNAME[0]}" != "error" ]; then echo "hello from error trap, exiting ${FUNCNAME[0]}()" >/dev/null; exiting_parent_function_from_error=0; return 1; fi' DEBUG

#correct behavior of error: break out of only its parent function, not all layers, not the script, just make the function that ran it return 1.
#or if error is run in the script, exit the script.
error() { #echo an error message in red text, and make the parent process (script or function) exit 1. Place "|| error '<explanation>'" at the end of ALL commands where success is necessary for proper function.
  echo -e "\e[91m$1\e[39m" 1>&2
  
  #if error is being run within another function, and we're not inside of api being sourced, and the trap payload that makes the parent function exit, then return 1
  #situation where the trap payload is unavailable: separate shells run by yad. Better to exit 1 than have error do nothing. (and sourcing api again would be overkill)
  if [ ${#FUNCNAME[@]} -gt 1 ] && [ "${FUNCNAME[1]}" != "source" ] && [[ "$(trap -p DEBUG)" == *exiting_parent_function_from_error* ]];then
    #set this variable that enables the trap trigger to do anything
    exiting_parent_function_from_error=1
    return 1
  else
    exit 1
  fi
}

warning() { #yellow text
  echo -e "\e[93m\e[5m◢◣\e[25m WARNING: $1\e[0m" 1>&2
}

status() { #cyan text to indicate what is happening
  
  #detect if a flag was passed, and if so, pass it on to the echo command
  if [[ "$1" == '-'* ]] && [ ! -z "$2" ];then
    echo -e $1 "\e[96m$2\e[0m" 1>&2
  else
    echo -e "\e[96m$1\e[0m" 1>&2
  fi
}

status_green() { #announce the success of a major action
  echo -e "\e[92m$1\e[0m" 1>&2
}

wait_for_file_creation() {
  local file="$1"
  if [ -z "$file" ]; then
    error "wait_for_file_creation() requires a file argument"
  elif [ -e "$file" ];then
    return 0 #file already exists, exit immediately
  fi
  
  #check for file existence again after inotifywait says "watches established"
  #prevents race condition with files being created before watches are set up
  local line
  while read line; do
    if [ -e "$file" ]; then
      return 0
    fi
  done < <(inotifywait -e create,moved_to "$(dirname "$file")" --include "$(basename "$file")" 2>&1)
}

run_on_exit() { #accumulative trap command for EXIT: put commands in $1 just like with trap
  exit_commands+=$'\n'"$1"
  trap "sleep 1"$'\n'"$exit_commands" EXIT
}

screenshot_fullscreen() { #take a screenshot of the full screen, save it to $1 png file
  if [[ "$1" != '/'* ]];then
    error "screenshot_fullscreen(): first argument must be a PNG filepath"
  fi
  
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    scrot -zoF "$1" || error "screenshot_fullscreen(): failed, please review errors above"
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    (sleep 2; warning "screenshot_fullscreen(): this is taking longer than expected. Most likely your wayland subscreen is not visible to your real screen, making it pause rendering. Please make the window visible, or switch to a headless subscreen.") &
    local warning_pid=$!
    grim "$1" || error "screenshot_fullscreen(): failed, please review errors above"
    kill $warning_pid 2>/dev/null || status_green "screenshot_fullscreen(): Screenshot succeeded. Proceeding..."
  else
    error "screenshot_fullscreen(): XDG_SESSION_TYPE needs to be set to either 'x11' or 'wayland'"
  fi
  
  if [ ! -f "$1" ];then
    error "screenshot_fullscreen(): screenshot tool somehow succeeded, but the screenshot was not saved to '$1'!"
  fi
}

crop_image() { #given a $1 png image, crop it to $2 rectangle coordinates (X,Y +W+H), and save to $3
  local inputfile="$1"
  local cropregion="$2"
  local outputfile="$3"
  
  if [ -z "$inputfile" ] || [ -z "$cropregion" ] || [ -z "$outputfile" ];then
    error "crop_image(): arguments required. [path to png image] [rectangle coordinates in the format 'X,Y +W+H']"
  elif [ ! -f "$inputfile" ];then
    error "crop_image(): input file '$inputfile' does not exist"
  fi
  
  #handle cases where we overwrite the original file
  local convert_destination="$outputfile"
  if [ "$inputfile" == "$outputfile" ];then
    convert_destination="$RAM_LOCATION/automaton-${inputfile//\//-}.png"
  fi
  #crop the image, using imagemagick's preferred crop format syntax
  convert "$inputfile" -crop "$(echo "$cropregion" | tr -d ' ' | tr ',+' ' ' | awk '{print $3"x"$4"+"$1"+"$2}')" +repage "$convert_destination" || error "Failed to crop image '$inputfile', please review errors above"
  
  #handle cases where we overwrite the original file - now overwrite it
  if [ "$inputfile" == "$outputfile" ];then
    mv -f "$convert_destination" "$outputfile" || error "Failed to overwrite '$outputfile'"
  fi
}

locator_start() { #this function has been renamed to daemon_start
  warning "locator_start(): this function has been renamed to daemon_start."
  daemon_start
}

locator_stop() { #this function has been renamed to daemon_stop
  warning "locator_stop(): this function has been renamed to daemon_stop."
  daemon_stop
}

daemon_start() { #start automaton utilities on the current screen or subscreen. Starts a vnc server and vnc_injector.py for mouse/keyboard usage, and starts locator.py for opencv to wait for targets on screen to find. Takes no arguments.
  if [ -z "$locator_pipe" ];then
    error 'daemon_start(): $locator_pipe is not set! This should have been set when sourcing the automaton api.'
  fi
  
  daemon_stop || error "daemon_start(): Failed to first daemon_stop!!"
  
  #run locator.py as a background process (it will stop when the named pipe is deleted)
  "$AUTOMATON_DIR/locator.py" "$locator_pipe" &
  
  #wait for the python script to create the named pipe using inotifywait
  timeout 10 bash -c "wait_for_file_creation '$locator_pipe.out'" || error "locator.py failed to initialize within 10 seconds. Please refer to errors above."
  
  #now start a vnc server and vnc_injector for mouse and keyboard movements that work the same on x11/wayland
  
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    x11vnc -q -display $DISPLAY -unixsock "$vnc_socket" -rfbport 0 -nopw &
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    wayvnc --render-cursor --unix-socket --socket="$vnc_control_socket" "$vnc_socket" &
  fi
  vnc_pid=$!
  
  #wait for the vnc server to be up and ready
  timeout 10 bash -c "wait_for_file_creation '$vnc_socket'" || error "daemon_start(): vnc server failed to launch on $XDG_SESSION_TYPE, please review errors above."
  
  #run vnc_injector.py as a background process (it will stop when the named pipe is deleted)
  "$AUTOMATON_DIR/vnc_injector.py" "$vnc_socket" "$vnc_pipe" &
  
  #wait for vnc_injector.py to be up and ready
  timeout 10 bash -c "wait_for_file_creation '$vnc_pipe'" || error "daemon_start(): vnc_injector.py failed to launch on $XDG_SESSION_TYPE, please review errors above."
}

daemon_stop() { #stops automaton utilities on the current screen or subscreen. Takes no arguments.
  rm -f "$locator_pipe" "$locator_pipe.out" "$vnc_socket" "$vnc_control_socket" "$vnc_pipe" || error "daemon_stop(): failed to remove some files from last time. Please review the above errors, and remove them manually."
  kill $vnc_pid &>/dev/null || true
}

locate_pattern() { #locate where on the screen the $1 pattern is, using opencv. $2 is optional offset argument in the form of +x+y, or a special offset 'center' which finds the midpoint of the pattern. Outputs X,Y. Exits with a stderr error message and exitcode 1, and no stdout output, if pattern not found. (set locate_pattern_stop_complaining=1 to hide the error)
  #pattern filename to look for (assumed to be saved in project folder)
  local pattern="$PATTERNS_DIR/$1"
  if [ ! -f "$pattern" ];then
    error "locate_pattern(): pattern png file at '$pattern' not found!"
  elif [ ! -p "$locator_pipe" ];then
    error "locate_pattern(): daemon_start must be run first! ($locator_pipe does not exist)"
  fi
  
  #wayland screenshots on Pi OS at least keep the mouse in view for some reason, so move the mouse to the bottom right corner if running in a subscreen
  #if [ "$XDG_SESSION_TYPE" == wayland ] && [ "$original_DISPLAY" != "$DISPLAY" ];then
    #moving the mouse in the main screen would compromise UX too much
    #wlrctl pointer move 1000000 1000000
  #fi
  #UPDATE: this seems to have been fixed on the pi os side... if uncommenting, don't use wlrctl
  
  #pixel offset provided ahead of time. Format: +X+Y
  if [[ "$2" == '+'* ]];then
    local offset="$2"
  elif [ "$2" == center ];then
    #If requested, use center midpoint of pattern, which is +L/2+W/2 of the image dimensions.
    local offset='' width='' height=''
    local IFS=' '
    read width height < <(identify -ping -format '%w %h' "$pattern")
    # Calculate midpoint
    offset="+$((width / 2))+$((height / 2))"
  elif [ ! -z "$2" ];then
    #offset not empty and unrecognized
    error "locate_pattern(): invalid offset value: '$2'"
  fi
  #echo "offset is $offset" 1>&2
  
  #save temporary screenshot to RAM - name it something unique for this script by using the full path of patterns directory, with '/' replaced with '-'
  local screenshot="$RAM_LOCATION/automaton-${my_pid}.png"
  screenshot_fullscreen "$screenshot" || return 1
  
  echo -e "$pattern\t$screenshot" > "$locator_pipe" #this will block until locator reads it
  #response is sent back through the pipe, this will wait for it
  
  local location
  local IFS=' '
  if read location similarity <"$locator_pipe.out" 2>/dev/null ;then #read blocks until something is in the output pipe
    #read returns code 0 if [ ! -z "$location" ]
    rm -f "$screenshot"
    if [ ! -z "$offset" ];then
      #if no offset given, output coordinates of top-left corner of pattern found
      #otherwise, apply the offset before outputting it
      local x_location="$(echo "$location" | awk -F, '{print $1}')"
      local y_location="$(echo "$location" | awk -F, '{print $2}')"
      local x_offset="$(echo "$offset" | awk -F + '{print $2}')"
      local y_offset="$(echo "$offset" | awk -F + '{print $3}')"
      location=$((x_location+x_offset)),$((y_location+y_offset))
    fi
    echo "$location $similarity"
    status_green "'$1' found at $location - $similarity"
  else
    #read returns code 1 if it received nothing (pattern not found)
    rm -f "$screenshot"
    #message user that pattern could not be found, UNLESS this function is being run by locate_pattern_retry
    local IFS=' '
    if [ "$locate_pattern_stop_complaining" == 1 ];then
      #avoid spamming, while allowing other error messages to go unhindered
      return 1
    else
      #run in parenthesis to ensure it acts as return 1, not exit 1, even though it should be return 1 with the trap trick
      (error "locate_pattern(): failed to find '$1' on screen.")
    fi
  fi
}

locate_pattern_retry() { #runs locate_pattern repeatedly until it succeeds. locate_pattern inherits all arguments, stdout/stderr is passed on.
  echo "Waiting to locate pattern '$1'... " 1>&2
  local locate_pattern_stop_complaining=1
  while ! locate_pattern "$@" ;do
    true
  done
}

mouse_move() { #move mouse to absolute position $1 (format X,Y). Rather than specify raw coordinates, use something like $(locate_pattern button.png center). Also, if applicable, don't forget to mouse_click after moving the mouse!
  local IFS=' ' #ensure the $() gets split into 2 arguments
  local coordinates="$(echo "$1" | awk '{print $1}')"
  if [ -z "$coordinates" ];then
    error "mouse_move(): no input coordinates"
  elif [[ "$coordinates" != *','* ]];then
    error "mouse_move(): input coordinates need to be specified in X,Y format, got '$coordinates'"
  elif [ ! -p "$vnc_pipe" ];then
    error "mouse_move(): $vnc_pipe does not exist. Please run the daemon_start function first."
  fi
  
  echo "mousemove $(echo "$coordinates" | tr ',' ' ')" > "$vnc_pipe"
}

mouse_click() { #normal mouse click
  if [ ! -p "$vnc_pipe" ];then
    error "mouse_click(): $vnc_pipe does not exist. Please run the daemon_start function first."
  fi
  
  echo "mouseclick 1" > "$vnc_pipe"
}

mouse_right_click() { #mouse do a right-click
  if [ ! -p "$vnc_pipe" ];then
    error "mouse_right_click(): $vnc_pipe does not exist. Please run the daemon_start function first."
  fi
  
  echo "mouseclick 3" > "$vnc_pipe"
}

mouse_middle_click() { #mouse press the scroll wheel
  if [ ! -p "$vnc_pipe" ];then
    error "mouse_middle_click(): $vnc_pipe does not exist. Please run the daemon_start function first."
  fi
  
  echo "mouseclick 2" > "$vnc_pipe"
}

mouse_scroll() { #scroll $1=[up/down] $2 times (scroll once if $2 not specified)
  local scrolldirection="$1"
  local scrolltimes="$2"
  if [ -z "$scrolltimes" ];then
    scrolltimes=1 #default value 1 if not set
  fi
  
  if [ ! -p "$vnc_pipe" ];then
    error "mouse_scroll(): $vnc_pipe does not exist. Please run the daemon_start function first."
  fi
  
  if [ "$scrolldirection" == down ];then
    #scroll down
    for ((n=0;n<$scrolltimes;n++)); do
      echo "mouseclick 5" > "$vnc_pipe"
    done
  elif [ "$scrolldirection" == up ];then
    #scroll up
    for ((n=0;n<$scrolltimes;n++)); do
      echo "mouseclick 4" > "$vnc_pipe"
    done
  else
    error "mouse_scroll(): first argument must be 'up' or 'down'. Got '$1'"
  fi
  sleep 0.5s #browsers animate after scroll event, so wait for it to finish
}

clipboard_set() { #copy text in $1 to the primary clipboard
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    echo -n "$1" | xclip -i -selection clipboard
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    echo -n "$1" | wl-copy
  fi
}

clipboard_dump() { #output the contents of the primary clipboard to stdout
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    xclip -o -selection clipboard
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    wl-paste
  fi
}

clipboard_selection_dump() { #output the contents of selected text to stdout
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    xclip -o -selection primary
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    wl-paste -p
  fi
}

keyboard_type() { #type text in $1 with the keyboard
  if [ ! -p "$vnc_pipe" ];then
    error "keyboard_type(): $vnc_pipe does not exist. Please run the daemon_start function first."
  fi
  echo "keyboardtype $1" > "$vnc_pipe"
}

keyboard_shortcut() { #press multiple keys at once, and special keys. one argument per key. Example: keyboard_shortcut Ctrl Alt a    Allowed special keys (case-insensitive): enter return backspace tab esc escape delete del home end pgup pageup pgdn pagedown left up right down f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 shift rshift ctrl rctrl control alt ralt meta super win cmd space
  local IFS=' ' #fixes $* from using \n separator
  if [ ! -p "$vnc_pipe" ];then
    error "keyboard_shortcut(): $vnc_pipe does not exist. Please run the daemon_start function first."
  fi
  echo "keyboardshortcut $*" > "$vnc_pipe"
}

subscreen_start() { #start a nested x or wayland display (type must be specified in $1: x11, x11-headless, wayland, wayland-headless)
  local display_type="$1"
  local display_dimensions="$2"
  local line
  #local subscreen_pid #don't make this local!!
  #parse display dimensions, if given
  local display_width
  local display_height
  if [ -z "$display_dimensions" ];then
    display_dimensions=1366x768
  fi
  display_width="$(echo "$display_dimensions" | awk -Fx '{print $1}')"
  display_height="$(echo "$display_dimensions" | awk -Fx '{print $2}')"
  if [ -z "$display_width" ] || [ -z "$display_height" ];then
    error "subscreen(): display dimensions not set correctly! Value was: '$display_dimensions'"
  fi
  
  case "$display_type" in
    x11|x11-headless)
      #find an unoccupied x display to use
      x_display=0
      while [ -e /tmp/.X11-unix/X$x_display ];do
        x_display=$((x_display+1))
      done
      
      #different tools are used, depending on whether the user wants a headless or a visible window
      case "$display_type" in
        x11)
        #xephyr
        Xephyr -no-host-grab -title "Automaton nested x11 display on :$x_display" -ac -screen ${display_width}x${display_height} -br -sw-cursor -glamor -dpi 96 ":$x_display" &
        subscreen_pid=$!
        ;;
      x11-headless)
        #xvfb
        Xvfb -ac -screen 0 ${display_width}x${display_height}x24 -br -dpi 96 ":$x_display" &
        subscreen_pid=$!
        ;;
      esac
      #before this function exits, the display needs to be ready for connections.
      #Wait for lockfile creation
      timeout 10 bash -c "wait_for_file_creation '/tmp/.X11-unix/X$x_display'" || error "subscreen_start(): $display_type failed to start in 10 seconds (/tmp/.X11-unix/X$x_display was not created)"
      
      #all apps downstream now use this DISPLAY and XDG_SESSION_TYPE, and ensure WAYLAND_DISPLAY is unset
      export XDG_SESSION_TYPE=x11
      export DISPLAY=:$x_display
      unset WAYLAND_DISPLAY
      export WAYLAND_DISPLAY
      
      #a desktop manager must be run, otherwise nothing can be resized or maximized
      local obconf='<?xml version="1.0" encoding="UTF-8"?><openbox_config><theme><name>Onyx</name></theme></openbox_config>'
      while read line ;do
        #run openbox in the background, but do not proceed until it has initialized
        if [ "$line" == 'openbox ready' ];then
          break
        fi
        #give openbox a minimal config so that it does not complain, and its output must be piped through cat, otherwise it instantly exits for some reason.
      done < <(echo "$obconf" | openbox --sm-disable --config-file /dev/stdin --startup 'echo openbox ready' | cat)
      ;;
    wayland|wayland-headless)
      #wayland nested display
      
      #determine which backend to use (the environment in which sway runs)
      local wlr_backend
      if [ "$display_type" == wayland-headless ];then
        wlr_backend="headless"
      elif [ "$XDG_SESSION_TYPE" == x11 ];then
        wlr_backend="x11"
      elif [ "$XDG_SESSION_TYPE" == wayland ];then
        wlr_backend="wayland"
      else
        error "subscreen_start(): Seems like your system is headless. (no wayland or x11 desktop session found)\nTo run this function headless, use the 'wayland-headless' mode."
      fi
      
      #determine output name for config
      local output_name
      case "$wlr_backend" in
        headless) output_name="HEADLESS-1" ;;
        x11) output_name="X11-1" ;;
        wayland) output_name="WAYLAND-1" ;;
      esac
      
      #create temporary sway config with resolution and startup echoes
      if [ -z "$sway_config" ];then
        error 'start_subscreen(): $sway_config should have been set when sourcing api'
      fi
      
      echo "output $output_name mode ${display_width}x${display_height}
# Force a default US keymap for all keyboards (virtual or physical)
input * xkb_layout ${XKB_DEFAULT_LAYOUT:-us}
xwayland enable
default_border none
exec echo "'"WAYLAND_DISPLAY=$WAYLAND_DISPLAY\nDISPLAY=$DISPLAY\nsway_ready"'"
exec echo sway_ready" > "$sway_config"
      #if there's a base config, you could include it: echo "include ${AUTOMATON_DIR}/sway.ini" at top
      
      #run sway, capture output to get the env variables
      local sway_succeeded=0
      while read line ;do
        if [[ "$line" == WAYLAND_DISPLAY=* ]] || [[ "$line" == DISPLAY=* ]];then
          export "$line" #export the variable that sway informed us of
          
        elif [[ "$line" == subscreen_pid=* ]];then
          export "$line" #export subscreen_pid for subscreen_stop
          
        elif [ "$line" == sway_ready ];then
          #if sway got far enough to run the execs, it did not fail
          sway_succeeded=1
          break #we have reached the end of useful output, DISPLAY and WAYLAND_DISPLAY have already been set, so exit and leave sway running as a background process
        fi
        #use sway because it is the only wayland compositor that works in nested mode on pi os (rules out wayfire), while being available on ubuntu repos (rules out labwc), while being based on wlroots (rules out mutter)
      done < <(unset XAUTHORITY; unset XDG_SEAT_PATH; unset XDG_SEAT ; WLR_BACKENDS="$wlr_backend" WLR_RENDERER=pixman WLR_NO_HARDWARE_CURSORS=1 WLR_RENDERER_FORCE_SOFTWARE=1 sway -c "$sway_config" & subscreen_pid=$! ; echo "subscreen_pid=$subscreen_pid" ; wait $subscreen_pid)
      rm "$sway_config"
      
      if [ "$sway_succeeded" == 0 ] || [ "$original_WAYLAND_DISPLAY" == "$WAYLAND_DISPLAY" ];then
        error "subscreen_start(): Sway failed to start! Please review errors above."
      fi
      
      #now no matter the original XDG_SESSION_TYPE, it's now wayland for all subsequent commands until subscreen_stop
      export XDG_SESSION_TYPE=wayland
      ;;
    *)
      error "subscreen(): not sure if you need a X11 or Wayland display, headless or not.\nPlease use 1 of the following 4 arguments: x11, x11-headless, wayland, wayland-headless"
      ;;
  esac
  #from this point on, any GUI programs run by the userscript will spawn in the nested display.
  
  #make sure the nested display is killed when the userscript ends
  run_on_exit "subscreen_stop"
}

subscreen_stop() { #stop a running subscreen. Takes no arguments.
  kill $subscreen_pid 2>/dev/null || true
  rm -f "$sway_config"
  export DISPLAY="$original_DISPLAY"
  export WAYLAND_DISPLAY="$original_WAYLAND_DISPLAY"
  export XDG_SESSION_TYPE="$original_XDG_SESSION_TYPE"
}

#set variables
export AUTOMATON_DIR #necessary because this is usually assigned before sourcing api, which runs `set -a`
if [ -z "$PATTERNS_DIR" ] && [ -z "$AUTOMATON_DIR" ];then
  error "api: PATTERNS_DIR and AUTOMATON_DIR must be set by the script that sources api"
elif [ ! -d "$PATTERNS_DIR" ] && [[ "$0" != */gui ]];then
  error "api: PATTERNS_DIR does not seem to be set correctly. ('$PATTERNS_DIR' does not exist)"
elif [ ! -f "$AUTOMATON_DIR/api" ];then
  error "api: AUTOMATON_DIR does not seem to be set correctly. ($AUTOMATON_DIR/api does not exist)"
fi

if [ -d /dev/shm ];then
  RAM_LOCATION=/dev/shm
else
  RAM_LOCATION=/tmp
fi
#other variables that we want global to modify later within functions:
subscreen_pid=''
my_pid=$$
#keep original values to these variables for subscreen_stop()
original_DISPLAY="$DISPLAY"
original_WAYLAND_DISPLAY="$WAYLAND_DISPLAY"
original_XDG_SESSION_TYPE="$XDG_SESSION_TYPE"
sway_config="$RAM_LOCATION/sway_config_${my_pid}.ini"

#install dependencies
install_list=()
#these are needed on both X11 or Wayland
if [ ! -d /usr/share/doc/python3-opencv ];then 
  install_list+=('python3-opencv')
fi
if [ ! -d /usr/share/doc/python3-numpy ];then
  install_list+=('python3-numpy')
fi
if ! command -v inotifywait >/dev/null ;then
  install_list+=('inotify-tools')
fi
if ! command -v identify >/dev/null ;then
  install_list+=('imagemagick-6.q16')
fi
#below this line are dependencies used by the gui
if [ ! -d /usr/share/doc/python3-pygame-sdl2 ];then
  install_list+=('python3-pygame-sdl2')
fi
if ! command -v yad >/dev/null ;then
  install_list+=('yad')
fi
if ! command -v shellcheck >/dev/null ;then
  install_list+=('shellcheck')
fi

#nested display tools: if you do not plan to use subscreen function, set SKIP_INSTALLING_SUBSCREEN_DEPS=1 to avoid installing these
if [ "$SKIP_INSTALLING_SUBSCREEN_DEPS" != 1 ];then
  if ! command -v Xvfb >/dev/null ;then
    install_list+=('xvfb')
  fi
  if ! command -v Xephyr >/dev/null ;then
    install_list+=('xserver-xephyr')
  fi
  if ! command -v sway >/dev/null ;then
    install_list+=('sway')
  fi
  if ! command -v openbox >/dev/null ;then
    install_list+=('openbox')
  fi
  if ! command -v python3 >/dev/null ;then
    install_list+=('python3')
  fi
fi

#X11 or Wayland have different dependencies
if [ "$XDG_SESSION_TYPE" == x11 ];then #these dependencies are required only on distros that are X11
  if ! command -v scrot >/dev/null ;then
    install_list+=('scrot')
  fi
  if ! command -v xclip >/dev/null ;then
    install_list+=('xclip')
  fi
  if ! command -v x11vnc >/dev/null ;then
    install_list+=('x11vnc')
  fi
elif [ "$XDG_SESSION_TYPE" == wayland ];then #these dependencies are required only on distros that are Wayland
  if ! command -v grim >/dev/null ;then
    install_list+=('grim')
  fi
  if ! command -v wl-copy >/dev/null ;then
    install_list+=('wl-clipboard')
  fi
  if ! command -v wayvnc >/dev/null ;then
    install_list+=('wayvnc')
  fi
fi
#now if anything is missing, install it
if [ ! -z "${install_list[*]}" ];then
  status "Installing dependencies... running sudo apt update"
  sudo apt update || true
  status "Installing dependencies: ${install_list[*]}"
  sudo apt install -y "${install_list[@]}" || error "Failed to install dependencies! Please install them yourself: ${install_list[*]}"
  status_green "Dependencies installed successfully."
fi

#now that dependencies are installed, do other things before userscript runs

#choose appropriate location for locator.py named pipe
locator_pipe="$PATTERNS_DIR/locator_pipe"

#choose appropriate location for vnc_injector.py named pipe
vnc_pipe="$PATTERNS_DIR/vnc_pipe"

#choose appropriate locations for vnc server socket and vnc control sockets
vnc_socket="$PATTERNS_DIR/vnc.sock"
vnc_control_socket="$PATTERNS_DIR/vnc-ctl.sock"
vnc_pid=''

#remove all these files while being sourced
rm -f "$locator_pipe" "$locator_pipe.out" "$vnc_pipe" "$vnc_socket" "$vnc_control_socket"

#track commands to run when a userscript ends
exit_commands=''
#stop daemon when userscript ends so only advanced users need to run daemon_stop
run_on_exit daemon_stop

#make ctrl+c behave the same as the script being killed (keeps loops from overriding ^C)
trap 'exit 0' SIGINT

status_green "Automaton API has been sourced"
