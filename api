#!/bin/bash

#export all functions and variables so they are reachable by bash subprocesses, such as in timeout and yad
set -a


#DO NOT use set -e. It breaks any function that needs to run a command (like yad) and check its error code with $?

#Make trap payload that exits out of parent function that ran error
set -o errtrace # Ensure ERR trap is inherited in functions
# Set ERR trap to exit from only the parent function that ran error
trap 'if [ "$exiting_parent_function_from_error" == 1 ] && [ ${#FUNCNAME[@]} -gt 1 ] && [ "${FUNCNAME[1]}" != "source" ]; then echo "hello from trap, exiting ${FUNCNAME[0]}()" >/dev/null; exiting_parent_function_from_error=0; return 1; fi' ERR

#correct behavior of error: break out of only its parent function, not all layers, not the script, just make the function that ran it return 1.
#or if error is run in the script, exit the script.
error() {
  echo -e "\e[91m$1\e[39m" 1>&2
  
  #if error is being run within another function, and we're not inside of api being sourced, and the trap payload that makes the parent function exit, then return 1
  #situation where the trap payload is unavailable: separate shells run by yad. Better to exit 1 than have error do nothing. (and sourcing api again would be overkill)
  if [ ${#FUNCNAME[@]} -gt 1 ] && [ "${FUNCNAME[1]}" != "source" ] && [[ "$(trap -p ERR)" == *exiting_parent_function_from_error* ]];then
    #set this variable that enables the trap trigger to do anything
    exiting_parent_function_from_error=1
    return 1
  else
    exit 1
  fi
}

warning() { #yellow text
  echo -e "\e[93m\e[5m◢◣\e[25m WARNING: $1\e[0m" 1>&2
}

status() { #cyan text to indicate what is happening
  
  #detect if a flag was passed, and if so, pass it on to the echo command
  if [[ "$1" == '-'* ]] && [ ! -z "$2" ];then
    echo -e $1 "\e[96m$2\e[0m" 1>&2
  else
    echo -e "\e[96m$1\e[0m" 1>&2
  fi
}

status_green() { #announce the success of a major action
  echo -e "\e[92m$1\e[0m" 1>&2
}

wait_for_file_creation() { #wait for the $1 file to be created, without using a loop
  if [ -z "$1" ];then
    error "wait_for_file_creation() requires a file argument"
  elif [ -e "$1" ];then
    return 0 #file already exists, exit immediately
  fi
  inotifywait -e create "$(dirname "$1")" --include "$(basename "$1")" -q >/dev/null
}

screenshot_fullscreen() { #take a screenshot of the full screen, save it to $1 png file
  if [[ "$1" != '/'* ]];then
    error "screenshot_fullscreen(): first argument must be a PNG filepath"
  fi
  
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    scrot -zoF "$1" || error "screenshot_fullscreen(): failed, please review errors above"
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    grim "$1" || error "screenshot_fullscreen(): failed, please review errors above"
  fi
}

crop_image() { #given a $1 png image, crop it to $2 rectangle coordinates (X,Y +W+H), and save to "$3"
  local inputfile="$1"
  local cropregion="$2"
  local outputfile="$3"
  
  if [ -z "$inputfile" ] || [ -z "$cropregion" ] || [ -z "$outputfile" ];then
    error "crop_image(): arguments required. [path to png image] [rectangle coordinates in the format 'X,Y +W+H']"
  elif [ ! -f "$inputfile" ];then
    error "crop_image(): input file '$inputfile' does not exist"
  fi
  
  #handle cases where we overwrite the original file
  local convert_destination="$outputfile"
  if [ "$inputfile" == "$outputfile" ];then
    convert_destination="$RAM_LOCATION/automaton-${inputfile//\//-}.png"
  fi
  #crop the image, using imagemagick's preferred crop format syntax
  convert "$inputfile" -crop "$(echo "$cropregion" | tr -d ' ' | tr ',+' ' ' | awk '{print $3"x"$4"+"$1"+"$2}')" +repage "$convert_destination" || error "Failed to crop image '$inputfile', please review errors above"
  
  #handle cases where we overwrite the original file - now overwrite it
  if [ "$inputfile" == "$outputfile" ];then
    mv -f "$convert_destination" "$outputfile" || error "Failed to overwrite '$outputfile'"
  fi
}

locator_start() { #start python opencv process that waits for targets on screen to find
  [ ! -z "$locator_pipe" ] || error 'locator_start(): $locator_pipe is not set! This should have been set when sourcing the automaton api.'
  
  rm -f "$locator_pipe" "${locator_pipe}.out" || error "locator_start(): Failed to first remove '$locator_pipe' file!"
  
  #run it as a background process (it will stop when the named pipe is deleted)
  "$AUTOMATON_DIR/locator.py" "$locator_pipe" &
  
  #wait for the python script to create the named pipe using inotifywait
  timeout 10 bash -c "wait_for_file_creation '$locator_pipe.out'" || error "locator.py failed to initialize within 10 seconds. Please refer to errors above."
}

locator_stop() {
  rm -f "$locator_pipe" || error "locator_stop(): Failed to remove '$locator_pipe'!"
  rm -f "${locator_pipe}.out" || error "locator_stop(): Failed to remove '${locator_pipe}.out'!"
}

locate_pattern() { #locate where on the screen the specified target is. (X,Y) No output if not found.
  #pattern filename to look for (assumed to be saved in project folder)
  local pattern="$PATTERNS_DIR/$1"
  [ -f "$pattern" ] || error "locate_pattern(): screenshot png file at '$pattern' not found!"
  [ -p "$locator_pipe" ] || error "locate_pattern(): locator_start must be run first! ($locator_pipe does not exist)"
  
  #pixel offset provided ahead of time. Format: +X+Y
  if [[ "$2" == '+'* ]];then
    local offset="$2"
  elif [ "$2" == center ];then
    #If requested, use center midpoint of pattern, which is +L/2+W/2 of the image dimensions.
    local offset='' width='' height=''
    local IFS=' '
    read width height < <(identify -ping -format '%w %h' "$pattern")
    # Calculate midpoint
    offset="+$((width / 2))+$((height / 2))"
  elif [ ! -z "$2" ];then
    #offset not empty and unrecognized
    error "locate_pattern(): invalid offset value: '$2'"
  fi
  #echo "offset is $offset" 1>&2
  
  #save temporary screenshot to RAM - name it something unique for this script by using the full path of patterns directory, with '/' replaced with '-'
  local screenshot="$RAM_LOCATION/automaton-${pattern//\//-}.png"
  screenshot_fullscreen "$screenshot" || return 1
  
  echo -e "$pattern\t$screenshot" > "$locator_pipe" #this will block until locator reads it
  #response is sent back through the pipe, this will wait for it
  
  local location
  local IFS=' '
  if read location similarity <"${locator_pipe}.out" 2>/dev/null ;then #read blocks until something is in the output pipe
    #read returns code 0 if [ ! -z "$location" ]
    rm -f "$screenshot"
    if [ ! -z "$offset" ];then
      #if no offset given, output coordinates of top-left corner of pattern found
      #otherwise, apply the offset before outputting it
      local x_location="$(echo "$location" | awk -F, '{print $1}')"
      local y_location="$(echo "$location" | awk -F, '{print $2}')"
      local x_offset="$(echo "$offset" | awk -F + '{print $2}')"
      local y_offset="$(echo "$offset" | awk -F + '{print $3}')"
      location=$((x_location+x_offset)),$((y_location+y_offset))
    fi
    echo "$location $similarity"
    status_green "'$1' found at $location - $similarity"
  else
    #read returns code 1 if it received nothing (pattern not found)
    rm -f "$screenshot"
    #message user that pattern could not be found, UNLESS this function is being run by locate_pattern_retry
    local IFS=' '
    if [[ " ${FUNCNAME[*]} " =~ " locate_pattern_retry " ]]; then
      #avoid spamming, while allowing other error messages to go unhindered
      return 1
    else
      #run in parenthesis so it acts as return 1, not exit 1
      (error "locate_pattern(): failed to find '$1' on screen.")
    fi
  fi
}

locate_pattern_retry() {
  echo "Waiting to locate pattern '$1'... " 1>&2
  while ! locate_pattern "$@" ;do
    true
  done
}

mouse_move() { #move mouse to absolute position $1 (format X,Y)
  local IFS=' '
  [ -z "$1" ] && error "mouse_move(): no input coordinates"
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    #xdotool allows absolute mouse movements
    xdotool mousemove --sync $(echo "$1" | tr ',' ' ')
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    #wlrctl only allows relative movements, so move to top left corner first
    wlrctl pointer move -1000000 -1000000
    #and then move to desired location, replacing ',' with space
    wlrctl pointer move $(echo "$1" | tr ',' ' ')
  fi
}

mouse_click() { #normal mouse click
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    xdotool click 1
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    wlrctl pointer click left
  fi
}

mouse_right_click() { #mouse do a right-click
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    xdotool click 3
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    wlrctl pointer click left
  fi
}

mouse_middle_click() { #mouse press the scroll wheel
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    xdotool click 2
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    wlrctl pointer click middle
  fi
}

mouse_scroll_down() { #scroll down $1 times (once if not specified)
  local scrolltimes="$1"
  if [ -z "$scrolltimes" ];then
    scrolltimes=1 #default value 1 if not set
  fi
  
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    for ((n=0;n<$scrolltimes;n++)); do
      xdotool click 5
    done
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    wlrctl pointer scroll $((15*scrolltimes))
  fi
  sleep 0.5s #browsers animate after scroll event, so wait for it to finish
}

mouse_scroll_up() { #scroll up $1 times (once if not specified)
  local scrolltimes="$1"
  if [ -z "$scrolltimes" ];then
    scrolltimes=1 #default value 1 if not set
  fi
  
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    for ((n=0;n<$scrolltimes;n++)); do
      xdotool click 4
    done
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    wlrctl pointer scroll $((-15*scrolltimes))
  fi
  sleep 0.5s #browsers animate after scroll event, so wait for it to finish
}

clipboard_set() { #copy text in $1 to the primary clipboard
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    echo -n "$1" | xclip -i -selection clipboard
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    echo -n "$1" | wl-copy -f
  fi
}

keyboard_type() { #type text in $1 with the keyboard
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    echo -n "$1" | xdotool type --file -
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    wlrctl type "$1"
  fi
}

keyboard_shortcut() { #press multiple keys at once, and special keys (one argument per key, as any delimiter used prevents that key from being used)
  local IFS='+'
  local wlrctl_modifiers=''
  local wlrctl_letterss=''
  while [ $# -gt 0 ]; do
    case "$1" in
      Ctrl)
        wlrctl_modifiers+=",CTRL"
        ;;
      Shift)
        wlrctl_modifiers+=",SHIFT"
        ;;
      Alt)
        wlrctl_modifiers+=",ALT"
        ;;
      Super)
        wlrctl_modifiers+=",SUPER"
        ;;
      Tab)
        wlrctl_letters+=$'\t'
        ;;
      Escape)
        wlrctl_letters+=$'\e'
        ;;
      Backspace)
        wlrctl_letters+=$'\b'
        ;;
      Enter)
        wlrctl_letters+=$'\n'
        ;;
      *)
        wlrctl_letters+="$key"
        ;;
    esac
    shift
  done
  if [ "$XDG_SESSION_TYPE" == x11 ];then
    #botspot finish this
    echo -n "$1" | xdotool type --file -
  elif [ "$XDG_SESSION_TYPE" == wayland ];then
    if [ -z "$wlrctl_letters" ];then
      error "On Wayland, wlrctl requires a key combination to use at least 1 key that is NOT one of the following keys: Ctrl, Shift, Alt, Super."
    elif [ ! -z "$wlrctl_modifiers" ];then
      wlrctl type "$wlrctl_letters" modifiers "$(echo "$wlrctl_modifiers" | sed 's/^,//g')"
    else
      wlrctl type "$wlrctl_letters"
    fi
  fi
}

subscreen_start() { #start a nested x or wayland display (must be specified)
  local display_type="$1"
  local display_dimensions="$2"
  
  #parse display dimensions, if given
  local display_width
  local display_height
  if [ -z "$display_dimensions" ];then
    display_dimensions=1366x768
  fi
  display_width="$(echo "$display_dimensions" | awk -Fx '{print $1}')"
  display_height="$(echo "$display_dimensions" | awk -Fx '{print $2}')"
  if [ -z "$display_width" ] || [ -z "$display_height" ];then
    error "subscreen(): display dimensions not set correctly! Value was: '$display_dimensions'"
  fi
  
  #weston can run x11 in wayland, wayland in x11, wayland in wayland, and x11 in x11. Splendid!!
  #it also autodetects unoccupied x11 and wayland displays, (unlike Xephyr/Xvfb) preventing these from needing to be handled here.
  case "$display_type" in
    x11|x11-headless)
      #find an unoccupied x display to use
      x_display=0
      while [ -e /tmp/.X11-unix/X$x_display ];do
        x_display=$((x_display+1))
      done
      
      #different tools are used, depending on whether the user wants a headless or a visible window
      case "$display_type" in
        x11)
        #xephyr
        Xephyr -no-host-grab -title "Automaton nested x11 display on :$x_display" -ac -screen ${display_width}x${display_height} -br -glamor -dpi 96 ":$x_display" &
        export subscreen_pid=$!
        ;;
      x11-headless)
        #xvfb
        Xvfb -ac -screen ${display_width}x${display_height} -br -glamor -dpi 96 ":$x_display" 2>/dev/null
        export subscreen_pid=$!
        ;;
      esac
      #before this function exits, the display needs to be ready for connections.
      #Wait for lockfile creation
      wait_for_file_creation /tmp/.X11-unix/X$x_display
      
      #all apps downstream now use this DISPLAY and XDG_SESSION_TYPE, and ensure WAYLAND_DISPLAY is unset
      export XDG_SESSION_TYPE=x11
      export DISPLAY=:$x_display
      unset WAYLAND_DISPLAY
      export WAYLAND_DISPLAY
      
      #a desktop manager must be run, otherwise nothing can be resized or maximized
      local obconf='<?xml version="1.0" encoding="UTF-8"?><openbox_config><theme><name>Onyx</name></theme></openbox_config>'
      while read line ;do
        #run openbox in the background, but do not proceed until it has initialized
        if [ "$line" == 'openbox ready' ];then
          break
        fi
        #give openbox a minimal config so that it does not complain, and its output must be piped through cat, otherwise it instantly exits for some reason.
      done < <(echo "$obconf" | openbox --sm-disable --config-file /dev/stdin --startup 'echo openbox ready' | cat)
      ;;
    wayland|wayland-headless)
      #wayland nested display
      
      #determine which backend to use (the environment in which weston runs)
      local weston_backend=()
      if [ "$display_type" == wayland-headless ];then
        weston_backend=(--backend="headless-backend.so")
      elif [ "$XDG_SESSION_TYPE" == x11 ];then
        weston_backend=(--backend="x11-backend.so")
      elif [ "$XDG_SESSION_TYPE" == wayland ];then
        weston_backend=(--backend="wayland-backend.so")
      else
        error "subscreen(): Seems like your system is headless. (no wayland or x11 desktop session found)\nTo run this function headless, use the 'wayland-headless' mode."
      fi
      
      #run weston, which runs env, so capture the new values of DISPLAY and WAYLAND_DISPLAY and export them 
      while read line ;do
        #echo "line is $line"
        if [[ "$line" == WAYLAND_DISPLAY=* ]] || [[ "$line" == DISPLAY=* ]];then
          export "$line" #export the variable that weston informed us of
          
        elif [[ "$line" == subscreen_pid=* ]];then
          export "$line" #export subscreen_pid for subscreen_stop
          
        elif [[ "$line" == WESTON_CONFIG_FILE=* ]];then
          break #we have reached the end of useful env output, DISPLAY and WAYLAND_DISPLAY have already been set, so exit and leave weston running as a background process
        fi
        export "$line" #export the variable that weston informed us of
        #to run weston on RPi with GPU acceleration, add MESA_LOADER_DRIVER_OVERRIDE=v3d and remove --use-pixman
        #weston version (on bookworm at least) does not support running a program directly on the command-line, or --renderer=pixman
      done < <(weston "${westonbackend[@]}" --width="$display_width" --height="$display_height" --use-pixman --xwayland -c "${AUTOMATON_DIR}/weston.ini" & subscreen_pid=$! ; echo "subscreen_pid=$subscreen_pid" ; wait $subscreen_pid)
      ;;
    *)
      error "subscreen(): not sure if you need a X11 or Wayland display, headless or not.\nPlease use 1 of the following 4 arguments: x11, x11-headless, wayland, wayland-headless"
      ;;
  esac
  #from this point on, any GUI programs run by the userscript will spawn in the nested display.
  
  #make sure the nested display is killed when the userscript ends
  trap "subscreen_stop" EXIT SIGINT
}

subscreen_stop() {
  kill $subscreen_pid 2>/dev/null || true
  export DISPLAY="$original_DISPLAY"
  export WAYLAND_DISPLAY="$original_WAYLAND_DISPLAY"
  export XDG_SESSION_TYPE="$original_XDG_SESSION_TYPE"
}

#set variables
export AUTOMATON_DIR #necessary because this is usually assigned before sourcing api, which runs `set -a`
if [ -z "$PATTERNS_DIR" ] && [ -z "$AUTOMATON_DIR" ];then
  error "api: PATTERNS_DIR and AUTOMATON_DIR must be set by the script that sources api"
elif [ ! -d "$PATTERNS_DIR" ] && [[ "$0" != */gui ]];then
  error "api: PATTERNS_DIR does not seem to be set correctly. ('$PATTERNS_DIR' does not exist)"
elif [ ! -f "$AUTOMATON_DIR/api" ];then
  error "api: AUTOMATON_DIR does not seem to be set correctly. ($AUTOMATON_DIR/api does not exist)"
fi

if [ -d /dev/shm ];then
  RAM_LOCATION=/dev/shm
else
  RAM_LOCATION=/tmp
fi
#other variables that we want global to modify later within functions:
subscreen_pid=''
#keep original values to these variables for subscreen_stop()
original_DISPLAY="$DISPLAY"
original_WAYLAND_DISPLAY="$WAYLAND_DISPLAY"
original_XDG_SESSION_TYPE="$XDG_SESSION_TYPE"

#install dependencies
install_list=()
#these are needed on both X11 or Wayland
if [ ! -d /usr/share/doc/python3-opencv ];then 
  install_list+=('python3-opencv')
fi
if [ ! -d /usr/share/doc/python3-numpy ];then
  install_list+=('python3-numpy')
fi
if ! command -v inotifywait >/dev/null ;then
  install_list+=('inotify-tools')
fi
if ! command -v identify >/dev/null ;then
  install_list+=('imagemagick-6.q16')
fi
#below this line are dependencies used by the gui
if [ ! -d /usr/share/doc/python3-pygame-sdl2 ];then
  install_list+=('python3-pygame-sdl2')
fi
if ! command -v yad >/dev/null ;then
  install_list+=('yad')
fi
if ! command -v shellcheck >/dev/null ;then
  install_list+=('shellcheck')
fi

#nested display tools: if you do not plan to use subscreen function, set SKIP_INSTALLING_SUBSCREEN_DEPS=1 to avoid installing these
if [ "$SKIP_INSTALLING_SUBSCREEN_DEPS" != 1 ];then
  if ! command -v Xvfb >/dev/null ;then
    install_list+=('xvfb')
  fi
  if ! command -v Xephyr >/dev/null ;then
    install_list+=('xserver-xephyr')
  fi
  if ! command -v weston >/dev/null ;then
    install_list+=('weston')
  fi
  if ! command -v openbox >/dev/null ;then
    install_list+=('openbox')
  fi
fi

#X11 or Wayland have different dependencies
if [ "$XDG_SESSION_TYPE" == x11 ];then #these dependencies are required only on distros that are X11
  if ! command -v xdotool >/dev/null ;then
    install_list+=('xdotool')
  fi
  if ! command -v scrot >/dev/null ;then
    install_list+=('scrot')
  fi
  if ! command -v xclip >/dev/null ;then
    install_list+=('xclip')
  fi
elif [ "$XDG_SESSION_TYPE" == wayland ];then #these dependencies are required only on distros that are Wayland
  #for compiling wlrctl
  if ! command -v wlrctl >/dev/null ;then
    need_to_compile_wlrctl=yes
    install_list+=('cmake' 'libxkbcommon-dev' 'libwayland-dev')
  fi
  if ! command -v grim >/dev/null ;then
    install_list+=('grim')
  fi
  if ! command -v wl-copy >/dev/null ;then
    install_list+=('wl-clipboard')
  fi
fi
#now if anything is missing, install it
if [ ! -z "${install_list[*]}" ];then
  status "Installing dependencies... running sudo apt update"
  sudo apt update || true
  status "Installing dependencies: ${install_list[*]}"
  sudo apt install -y "${install_list[@]}" || error "Failed to install dependencies! Please install them yourself: ${install_list[*]}"
  status_green "Dependencies installed successfully."
fi

#compile and install wlrctl if on wayland
if [ "$need_to_compile_wlrctl" == yes ];then
  status "Compiling wlrctl..."
  #run in a subshell to avoid changing current directory (downloads and installs in ram)
  (cd "$RAM_LOCATION"
  rm -rf ./wlrctl
  git clone https://git.sr.ht/~brocellous/wlrctl || exit 1
  cd wlrctl
  meson setup --prefix=/usr/local build || exit 1
  sudo ninja -C build install || exit 1
  cd "$RAM_LOCATION"
  rm -rf ./wlrctl) || error "Failed to compile wlrctl. Please review errors above."
  status_green "wlrctl has installed successfully."
fi
#now that dependencies are installed, do other things before userscript runs

#choose appropriate location for locator.py named pipe
locator_pipe="$PATTERNS_DIR/locator_pipe"
#remove it while being sourced
rm -f "$locator_pipe"

#stop locator.py when userscript ends so only advanced users need to run locator_stop
trap locator_stop EXIT SIGINT

status_green "Automaton API has been sourced"
